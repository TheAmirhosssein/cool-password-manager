/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/3dh_client.js"
/*!******************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/3dh_client.js ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AKE3DHClient: () => (/* binding */ AKE3DHClient)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/common.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nclass AKE3DHClient {\n    constructor(config) {\n        this.config = config;\n    }\n    async start() {\n        const client_nonce = this.config.prng.random(this.config.constants.Nn);\n        const { private_key: client_secret, public_key: client_keyshare } = await this.config.ake.generateAuthKeyPair();\n        this.client_secret = new Uint8Array(client_secret);\n        return new _messages_js__WEBPACK_IMPORTED_MODULE_0__.AuthInit(this.config, new Uint8Array(client_nonce), new Uint8Array(client_keyshare));\n    }\n    async finalize(client_identity, client_private_key, server_identity, server_public_key, ke1, ke2, context) {\n        if (typeof this.client_secret === 'undefined') {\n            return new Error('ake3dhclient has not started yet');\n        }\n        const ikm = (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.tripleDH_IKM)(this.config, [\n            { sk: this.client_secret, pk: ke2.auth_response.server_keyshare },\n            { sk: this.client_secret, pk: server_public_key },\n            { sk: client_private_key, pk: ke2.auth_response.server_keyshare }\n        ]);\n        const preamble = (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.preambleBuild)(ke1, ke2, server_identity, client_identity, context);\n        const { Km2, Km3, session_key } = await (0,_common_js__WEBPACK_IMPORTED_MODULE_1__.deriveKeys)(this.config, ikm, preamble);\n        const h_preamble = await this.config.hash.sum(preamble);\n        if (!(await (await this.config.mac.with_key(Km2)).verify(h_preamble, ke2.auth_response.server_mac))) {\n            return new Error('handshake error');\n        }\n        const hmacData = await this.config.hash.sum((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([preamble, ke2.auth_response.server_mac]));\n        const client_mac = await (await this.config.mac.with_key(Km3)).sign(hmacData);\n        const auth_finish = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.AuthFinish(this.config, client_mac);\n        return { auth_finish, session_key };\n    }\n}\n//# sourceMappingURL=3dh_client.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/3dh_client.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/3dh_server.js"
/*!******************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/3dh_server.js ***!
  \******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AKE3DHServer: () => (/* binding */ AKE3DHServer)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/common.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nclass AKE3DHServer {\n    constructor(config) {\n        this.config = config;\n    }\n    async response(server_private_key, server_identity, ke1, credential_response, context, client_public_key, client_identity) {\n        const server_nonce = this.config.prng.random(this.config.constants.Nn);\n        const { private_key: server_secret, public_key: server_keyshare } = await this.config.ake.generateAuthKeyPair();\n        const tmp_server_mac = new Uint8Array(this.config.mac.Nm);\n        const auth_response = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.AuthResponse(this.config, new Uint8Array(server_nonce), new Uint8Array(server_keyshare), tmp_server_mac);\n        const ke2 = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.KE2(credential_response, auth_response);\n        const preamble = (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.preambleBuild)(ke1, ke2, server_identity, client_identity ? client_identity : client_public_key, context);\n        const ikm = (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.tripleDH_IKM)(this.config, [\n            { sk: new Uint8Array(server_secret), pk: ke1.auth_init.client_keyshare },\n            { sk: server_private_key, pk: ke1.auth_init.client_keyshare },\n            { sk: new Uint8Array(server_secret), pk: client_public_key }\n        ]);\n        const { Km2, Km3, session_key } = await (0,_common_js__WEBPACK_IMPORTED_MODULE_2__.deriveKeys)(this.config, ikm, preamble);\n        const h_preamble = await this.config.hash.sum(preamble);\n        const server_mac = await (await this.config.mac.with_key(Km2)).sign(h_preamble);\n        const h_preamble_mac = await this.config.hash.sum((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([preamble, server_mac]));\n        const expected_client_mac = await (await this.config.mac.with_key(Km3)).sign(h_preamble_mac);\n        const expected = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.ExpectedAuthResult(this.config, expected_client_mac, session_key);\n        ke2.auth_response.server_mac = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.checked_vector)(server_mac, this.config.mac.Nm);\n        return { ke2, expected };\n    }\n    // eslint-disable-next-line class-methods-use-this\n    finish(auth_finish, expected) {\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.ctEqual)(auth_finish.client_mac, expected.expected_client_mac)) {\n            return new Error('handshake error');\n        }\n        return { session_key: Array.from(expected.session_key) };\n    }\n}\n//# sourceMappingURL=3dh_server.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/3dh_server.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/common.js"
/*!**************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/common.js ***!
  \**************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AKE3DH: () => (/* binding */ AKE3DH),\n/* harmony export */   LABELS: () => (/* binding */ LABELS),\n/* harmony export */   OPRFBaseMode: () => (/* binding */ OPRFBaseMode),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   preambleBuild: () => (/* binding */ preambleBuild),\n/* harmony export */   tripleDH_IKM: () => (/* binding */ tripleDH_IKM)\n/* harmony export */ });\n/* harmony import */ var _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cloudflare/voprf-ts */ \"./node_modules/@cloudflare/voprf-ts/lib/src/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nconst te = new TextEncoder();\nfunction encStr(s) {\n    return Array.from(te.encode(s));\n}\nconst LABELS = {\n    AuthKey: encStr('AuthKey'),\n    ClientMAC: encStr('ClientMAC'),\n    CredentialResponsePad: encStr('CredentialResponsePad'),\n    ExportKey: encStr('ExportKey'),\n    HandshakeSecret: encStr('HandshakeSecret'),\n    MaskingKey: encStr('MaskingKey'),\n    OPAQUE: encStr('OPAQUE-'),\n    OPAQUE_DeriveAuthKeyPair: encStr('OPAQUE-DeriveAuthKeyPair'),\n    OPAQUE_DeriveKeyPair: encStr('OPAQUE-DeriveKeyPair'),\n    OprfKey: encStr('OprfKey'),\n    PrivateKey: encStr('PrivateKey'),\n    RFC: encStr('RFCXXXX'),\n    ServerMAC: encStr('ServerMAC'),\n    SessionKey: encStr('SessionKey')\n};\nclass OPRFBaseMode {\n    constructor(id) {\n        this.id = id;\n        const { blindedSize, hash } = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id);\n        this.Noe = blindedSize;\n        this.hash = hash;\n        this.name = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.OprfID[id];\n    }\n    async blind(input) {\n        const res = await new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.OPRFClient(this.id).blind(input);\n        return {\n            blind: new Uint8Array(res.blind.buffer),\n            blindedElement: new Uint8Array(res.blindedElement.buffer)\n        };\n    }\n    async evaluate(key, blinded) {\n        const res = await new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.OPRFServer(this.id, key).evaluate(new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Blinded(blinded), new Uint8Array());\n        return new Uint8Array(res.buffer);\n    }\n    finalize(input, blind, evaluation) {\n        return new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.OPRFClient(this.id).finalize(input, new Uint8Array(), new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Blind(blind), new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Evaluation(evaluation));\n    }\n    async deriveOPRFKey(seed) {\n        const { gg } = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(this.id);\n        const priv = await gg.hashToScalar(seed, Uint8Array.from(LABELS.OPAQUE_DeriveKeyPair));\n        return new Uint8Array(gg.serializeScalar(priv));\n    }\n}\nfunction expandLabel(cfg, secret, label, context, length) {\n    const customLabel = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_number)(length, 16),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_vector_8)((0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([Uint8Array.from(LABELS.OPAQUE), label])),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_vector_8)(context)\n    ]);\n    return cfg.kdf.expand(secret, customLabel, length);\n}\nfunction deriveSecret(cfg, secret, label, transHash) {\n    return expandLabel(cfg, secret, label, transHash, cfg.kdf.Nx);\n}\nfunction preambleBuild(ke1, ke2, server_identity, client_identity, context) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([\n        Uint8Array.from(LABELS.RFC),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_vector_16)(context),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_vector_16)(client_identity),\n        Uint8Array.from(ke1.serialize()),\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.encode_vector_16)(server_identity),\n        Uint8Array.from(ke2.response.serialize()),\n        ke2.auth_response.server_nonce,\n        ke2.auth_response.server_keyshare\n    ]);\n}\nfunction tripleDH_IKM(cfg, keys) {\n    const { gg } = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(cfg.oprf.id);\n    const ikm = new Array(3);\n    for (let i = 0; i < 3; i++) {\n        const { sk, pk } = keys[i];\n        const point = gg.deserialize(new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.SerializedElt(pk));\n        const scalar = gg.deserializeScalar(new _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.SerializedScalar(sk));\n        const p = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Group.mul(scalar, point);\n        ikm[i] = gg.serialize(p);\n    }\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)(ikm);\n}\nasync function deriveKeys(cfg, ikm, preamble) {\n    const nosalt = new Uint8Array(cfg.hash.Nh);\n    const prk = await cfg.kdf.extract(nosalt, ikm);\n    const h_preamble = await cfg.hash.sum(preamble);\n    const handshake_secret = await deriveSecret(cfg, prk, Uint8Array.from(LABELS.HandshakeSecret), h_preamble);\n    const session_key = await deriveSecret(cfg, prk, Uint8Array.from(LABELS.SessionKey), h_preamble);\n    const no_transcript = new Uint8Array();\n    const Km2 = await deriveSecret(cfg, handshake_secret, Uint8Array.from(LABELS.ServerMAC), no_transcript);\n    const Km3 = await deriveSecret(cfg, handshake_secret, Uint8Array.from(LABELS.ClientMAC), no_transcript);\n    return { Km2, Km3, session_key };\n}\nclass AKE3DH {\n    constructor(oprfID) {\n        this.oprfID = oprfID;\n        const { Npk, Nsk } = (0,_cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.getKeySizes)(oprfID);\n        this.Npk = Npk;\n        this.Nsk = Nsk;\n    }\n    async deriveAuthKeyPair(seed) {\n        const { gg } = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(this.oprfID);\n        const priv = await gg.hashToScalar(seed, Uint8Array.from(LABELS.OPAQUE_DeriveAuthKeyPair));\n        const private_key = new Uint8Array(gg.serializeScalar(priv));\n        const public_key = (0,_cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.generatePublicKey)(this.oprfID, private_key);\n        return { private_key, public_key };\n    }\n    recoverPublicKey(private_key) {\n        const public_key = (0,_cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.generatePublicKey)(this.oprfID, private_key);\n        return { private_key, public_key };\n    }\n    async generateAuthKeyPair() {\n        const keypair = this.recoverPublicKey(await (0,_cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_0__.randomPrivateKey)(this.oprfID));\n        return {\n            private_key: Array.from(keypair.private_key),\n            public_key: Array.from(keypair.public_key)\n        };\n    }\n}\n//# sourceMappingURL=common.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/common.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/core_client.js"
/*!*******************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/core_client.js ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueCoreClient: () => (/* binding */ OpaqueCoreClient)\n/* harmony export */ });\n/* harmony import */ var _thecrypto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./thecrypto.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js\");\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/common.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\n\nclass CleartextCredentials {\n    constructor(cfg, server_public_key, client_public_key, server_identity, client_identity) {\n        this.server_public_key = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.checked_vector)(server_public_key, cfg.ake.Npk);\n        this.server_identity = server_identity ? server_identity : server_public_key;\n        this.client_identity = client_identity ? client_identity : client_public_key;\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([\n            this.server_public_key,\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.encode_vector_16)(this.server_identity),\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.encode_vector_16)(this.client_identity)\n        ]));\n    }\n}\nasync function expand_keys(cfg, randomized_pwd, envelope_nonce) {\n    const auth_key = await cfg.kdf.expand(randomized_pwd, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([envelope_nonce, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.AuthKey)]), cfg.hash.Nh);\n    const export_key = await cfg.kdf.expand(randomized_pwd, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([envelope_nonce, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.ExportKey)]), cfg.hash.Nh);\n    const seed = await cfg.kdf.expand(randomized_pwd, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([envelope_nonce, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.PrivateKey)]), cfg.constants.Nseed);\n    const client_ake_keypair = await cfg.ake.deriveAuthKeyPair(seed);\n    return { auth_key, export_key, client_ake_keypair };\n}\nasync function store(cfg, randomized_pwd, server_public_key, server_identity, client_identity) {\n    const envelope_nonce = new Uint8Array(cfg.prng.random(cfg.constants.Nn));\n    const { auth_key, export_key, client_ake_keypair } = await expand_keys(cfg, randomized_pwd, envelope_nonce);\n    const { public_key: client_public_key } = client_ake_keypair;\n    const cleartext_creds = new CleartextCredentials(cfg, server_public_key, client_public_key, server_identity, client_identity);\n    const auth_msg = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([envelope_nonce, Uint8Array.from(cleartext_creds.serialize())]);\n    const auth_tag = await (await cfg.mac.with_key(auth_key)).sign(auth_msg);\n    const envelope = new _messages_js__WEBPACK_IMPORTED_MODULE_1__.Envelope(cfg, envelope_nonce, auth_tag);\n    const masking_key = await cfg.kdf.expand(randomized_pwd, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.MaskingKey), cfg.hash.Nh);\n    return { envelope, client_public_key, masking_key, export_key };\n}\nasync function recover(cfg, envelope, randomized_pwd, server_public_key, server_identity, client_identity) {\n    const { auth_key, export_key, client_ake_keypair } = await expand_keys(cfg, randomized_pwd, envelope.nonce);\n    const { public_key: client_public_key } = client_ake_keypair;\n    const cleartext_creds = new CleartextCredentials(cfg, server_public_key, client_public_key, server_identity, client_identity);\n    const auth_msg = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([envelope.nonce, Uint8Array.from(cleartext_creds.serialize())]);\n    const mac = await cfg.mac.with_key(auth_key);\n    if (!(await mac.verify(auth_msg, envelope.auth_tag))) {\n        return new Error('EnvelopeRecoveryError');\n    }\n    return { client_ake_keypair, export_key };\n}\nclass OpaqueCoreClient {\n    constructor(config, memHard = _thecrypto_js__WEBPACK_IMPORTED_MODULE_0__.ScryptMemHardFn) {\n        this.config = config;\n        this.memHard = memHard;\n    }\n    async createRegistrationRequest(password) {\n        const { blindedElement: M, blind } = await this.config.oprf.blind(password);\n        const request = new _messages_js__WEBPACK_IMPORTED_MODULE_1__.RegistrationRequest(this.config, M);\n        return { request, blind };\n    }\n    async finalizeRequest(password, blind, response, server_identity, client_identity) {\n        const y = await this.config.oprf.finalize(password, blind, response.evaluation);\n        const nosalt = new Uint8Array(this.config.hash.Nh);\n        const randomized_pwd = await this.config.kdf.extract(nosalt, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([y, this.memHard.harden(y)]));\n        const { envelope, client_public_key, masking_key, export_key } = await store(this.config, randomized_pwd, response.server_public_key, server_identity, client_identity);\n        const record = new _messages_js__WEBPACK_IMPORTED_MODULE_1__.RegistrationRecord(this.config, client_public_key, masking_key, envelope);\n        return { record, export_key: Array.from(export_key) };\n    }\n    async createCredentialRequest(password) {\n        const { blindedElement: M, blind } = await this.config.oprf.blind(password);\n        const request = new _messages_js__WEBPACK_IMPORTED_MODULE_1__.CredentialRequest(this.config, M);\n        return { request, blind };\n    }\n    async recoverCredentials(password, blind, response, server_identity, client_identity) {\n        const y = await this.config.oprf.finalize(password, blind, response.evaluation);\n        const nosalt = new Uint8Array(this.config.hash.Nh);\n        const randomized_pwd = await this.config.kdf.extract(nosalt, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([y, this.memHard.harden(y)]));\n        const masking_key = await this.config.kdf.expand(randomized_pwd, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.MaskingKey), this.config.hash.Nh);\n        const Ne = _messages_js__WEBPACK_IMPORTED_MODULE_1__.Envelope.sizeSerialized(this.config);\n        const credential_response_pad = await this.config.kdf.expand(masking_key, (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.joinAll)([response.masking_nonce, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_3__.LABELS.CredentialResponsePad)]), this.config.ake.Npk + Ne);\n        const server_pub_key_enve = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.xor)(credential_response_pad, response.masked_response);\n        const server_public_key = server_pub_key_enve.slice(0, this.config.ake.Npk);\n        const { Npk } = this.config.ake;\n        const envelope_bytes = server_pub_key_enve.slice(Npk, Npk + Ne);\n        const envelope = _messages_js__WEBPACK_IMPORTED_MODULE_1__.Envelope.deserialize(this.config, Array.from(envelope_bytes));\n        const rec = await recover(this.config, envelope, randomized_pwd, server_public_key, server_identity, client_identity);\n        if (rec instanceof Error) {\n            return rec;\n        }\n        return { server_public_key, ...rec };\n    }\n}\n//# sourceMappingURL=core_client.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/core_client.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/core_server.js"
/*!*******************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/core_server.js ***!
  \*******************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueCoreServer: () => (/* binding */ OpaqueCoreServer)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/common.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nclass OpaqueCoreServer {\n    constructor(config, oprf_seed) {\n        this.config = config;\n        this.oprf_seed = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.checked_vector)(oprf_seed, config.hash.Nh);\n    }\n    async doOPRFEvaluation(blinded, credential_identifier) {\n        const oprf_key_seed = await this.config.kdf.expand(this.oprf_seed, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([credential_identifier, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_2__.LABELS.OprfKey)]), this.config.constants.Nseed);\n        const oprf_key = await this.config.oprf.deriveOPRFKey(oprf_key_seed);\n        return this.config.oprf.evaluate(oprf_key, blinded);\n    }\n    async createRegistrationResponse(request, server_public_key, credential_identifier) {\n        const evaluation = await this.doOPRFEvaluation(request.data, credential_identifier);\n        return new _messages_js__WEBPACK_IMPORTED_MODULE_0__.RegistrationResponse(this.config, evaluation, server_public_key);\n    }\n    async createCredentialResponse(request, record, server_public_key, credential_identifier) {\n        const evaluation = await this.doOPRFEvaluation(request.data, credential_identifier);\n        const masking_nonce = new Uint8Array(this.config.prng.random(this.config.constants.Nn));\n        const Ne = _messages_js__WEBPACK_IMPORTED_MODULE_0__.Envelope.sizeSerialized(this.config);\n        const credential_response_pad = await this.config.kdf.expand(record.masking_key, (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([masking_nonce, Uint8Array.from(_common_js__WEBPACK_IMPORTED_MODULE_2__.LABELS.CredentialResponsePad)]), this.config.ake.Npk + Ne);\n        const plaintext = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([server_public_key, Uint8Array.from(record.envelope.serialize())]);\n        const masked_response = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.xor)(credential_response_pad, plaintext);\n        return new _messages_js__WEBPACK_IMPORTED_MODULE_0__.CredentialResponse(this.config, evaluation, masking_nonce, masked_response);\n    }\n}\n//# sourceMappingURL=core_server.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/core_server.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/index.js"
/*!*************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/index.js ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CredentialFile: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.CredentialFile),\n/* harmony export */   ExpectedAuthResult: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.ExpectedAuthResult),\n/* harmony export */   IdentityMemHardFn: () => (/* reexport safe */ _thecrypto_js__WEBPACK_IMPORTED_MODULE_4__.IdentityMemHardFn),\n/* harmony export */   KE1: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.KE1),\n/* harmony export */   KE2: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.KE2),\n/* harmony export */   KE3: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.KE3),\n/* harmony export */   OpaqueClient: () => (/* reexport safe */ _opaque_client_js__WEBPACK_IMPORTED_MODULE_2__.OpaqueClient),\n/* harmony export */   OpaqueID: () => (/* reexport safe */ _suites_js__WEBPACK_IMPORTED_MODULE_0__.OpaqueID),\n/* harmony export */   OpaqueServer: () => (/* reexport safe */ _opaque_server_js__WEBPACK_IMPORTED_MODULE_3__.OpaqueServer),\n/* harmony export */   RegistrationRecord: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.RegistrationRecord),\n/* harmony export */   RegistrationRequest: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.RegistrationRequest),\n/* harmony export */   RegistrationResponse: () => (/* reexport safe */ _messages_js__WEBPACK_IMPORTED_MODULE_1__.RegistrationResponse),\n/* harmony export */   ScryptMemHardFn: () => (/* reexport safe */ _thecrypto_js__WEBPACK_IMPORTED_MODULE_4__.ScryptMemHardFn),\n/* harmony export */   getOpaqueConfig: () => (/* reexport safe */ _suites_js__WEBPACK_IMPORTED_MODULE_0__.getOpaqueConfig)\n/* harmony export */ });\n/* harmony import */ var _suites_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./suites.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/suites.js\");\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _opaque_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./opaque_client.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/opaque_client.js\");\n/* harmony import */ var _opaque_server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./opaque_server.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/opaque_server.js\");\n/* harmony import */ var _thecrypto_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./thecrypto.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/index.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/messages.js"
/*!****************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/messages.js ***!
  \****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthFinish: () => (/* binding */ AuthFinish),\n/* harmony export */   AuthInit: () => (/* binding */ AuthInit),\n/* harmony export */   AuthResponse: () => (/* binding */ AuthResponse),\n/* harmony export */   CredentialFile: () => (/* binding */ CredentialFile),\n/* harmony export */   CredentialRequest: () => (/* binding */ CredentialRequest),\n/* harmony export */   CredentialResponse: () => (/* binding */ CredentialResponse),\n/* harmony export */   Envelope: () => (/* binding */ Envelope),\n/* harmony export */   ExpectedAuthResult: () => (/* binding */ ExpectedAuthResult),\n/* harmony export */   KE1: () => (/* binding */ KE1),\n/* harmony export */   KE2: () => (/* binding */ KE2),\n/* harmony export */   KE3: () => (/* binding */ KE3),\n/* harmony export */   RegistrationRecord: () => (/* binding */ RegistrationRecord),\n/* harmony export */   RegistrationRequest: () => (/* binding */ RegistrationRequest),\n/* harmony export */   RegistrationResponse: () => (/* binding */ RegistrationResponse),\n/* harmony export */   Serializable: () => (/* binding */ Serializable)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\nclass Serializable {\n    static check_string(a) {\n        if (typeof a === 'string') {\n            return true;\n        }\n        throw new Error('string expected');\n    }\n    static check_uint8array(a) {\n        if (a instanceof Uint8Array) {\n            return true;\n        }\n        throw new Error('Uint8Array expected');\n    }\n    static check_uint8arrays(as) {\n        return as.every(this.check_uint8array);\n    }\n    static check_bytes_array(a) {\n        if (!Array.isArray(a) ||\n            !a.every((element) => Number.isInteger(element) && element >= 0 && element <= 255)) {\n            throw new Error('Array of byte-sized integers expected');\n        }\n        return true;\n    }\n    static check_bytes_arrays(as) {\n        return as.every(this.check_bytes_array);\n    }\n    static sizeSerialized(_) {\n        throw new Error('child class must implement');\n    }\n    static checked_bytes_to_uint8array(cfg, bytes) {\n        this.check_bytes_array(bytes);\n        const u8array = Uint8Array.from(bytes);\n        this.checked_object(cfg, u8array);\n        return u8array;\n    }\n    static checked_object(cfg, u8array) {\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(u8array, this.sizeSerialized(cfg), this.name);\n    }\n}\nclass Envelope extends Serializable {\n    constructor(cfg, nonce, auth_tag) {\n        super();\n        this.nonce = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(nonce, cfg.constants.Nn);\n        this.auth_tag = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(auth_tag, cfg.mac.Nm);\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.nonce, this.auth_tag]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.constants.Nn + cfg.mac.Nm;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.constants.Nn;\n        const nonce = u8array.slice(start, end);\n        start = end;\n        end += cfg.mac.Nm;\n        const auth_tag = u8array.slice(start, end);\n        return new Envelope(cfg, nonce, auth_tag);\n    }\n}\nclass RegistrationRequest extends Serializable {\n    constructor(cfg, data) {\n        Serializable.check_uint8array(data);\n        super();\n        this.data = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(data, cfg.oprf.Noe);\n    }\n    serialize() {\n        return Array.from(this.data);\n    }\n    static sizeSerialized(cfg) {\n        return cfg.oprf.Noe;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        const start = 0;\n        const end = cfg.oprf.Noe;\n        const data = u8array.slice(start, end);\n        return new RegistrationRequest(cfg, data);\n    }\n}\nclass RegistrationResponse extends Serializable {\n    constructor(cfg, data, server_public_key) {\n        Serializable.check_uint8arrays([data, server_public_key]);\n        super();\n        this.evaluation = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(data, cfg.oprf.Noe);\n        this.server_public_key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(server_public_key, cfg.ake.Npk);\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.evaluation, this.server_public_key]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.oprf.Noe + cfg.ake.Npk;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.oprf.Noe;\n        const evaluation = u8array.slice(start, end);\n        start = end;\n        end += cfg.ake.Npk;\n        const server_public_key = u8array.slice(start, end);\n        return new RegistrationResponse(cfg, evaluation, server_public_key);\n    }\n}\nclass RegistrationRecord extends Serializable {\n    constructor(cfg, client_public_key, masking_key, envelope) {\n        Serializable.check_uint8arrays([client_public_key, masking_key]);\n        super();\n        this.client_public_key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(client_public_key, cfg.ake.Npk);\n        this.masking_key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(masking_key, cfg.hash.Nh);\n        this.envelope = envelope;\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([\n            this.client_public_key,\n            this.masking_key,\n            Uint8Array.from(this.envelope.serialize())\n        ]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.ake.Npk + cfg.hash.Nh + Envelope.sizeSerialized(cfg);\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.ake.Npk;\n        const client_public_key = u8array.slice(start, end);\n        start = end;\n        end += cfg.hash.Nh;\n        const masking_key = u8array.slice(start, end);\n        start = end;\n        end += Envelope.sizeSerialized(cfg);\n        const envelope_bytes = u8array.slice(start, end);\n        const envelope = Envelope.deserialize(cfg, Array.from(envelope_bytes));\n        return new RegistrationRecord(cfg, client_public_key, masking_key, envelope);\n    }\n    static async createFake(cfg) {\n        const seed = cfg.prng.random(cfg.constants.Nseed);\n        const { public_key: client_public_key } = await cfg.ake.deriveAuthKeyPair(new Uint8Array(seed));\n        const masking_key = new Uint8Array(cfg.prng.random(cfg.hash.Nh));\n        const envelope = Envelope.deserialize(cfg, new Array(Envelope.sizeSerialized(cfg)).fill(0));\n        return new RegistrationRecord(cfg, client_public_key, masking_key, envelope);\n    }\n}\nclass CredentialRequest extends Serializable {\n    constructor(cfg, data) {\n        Serializable.check_uint8array(data);\n        super();\n        this.data = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(data, cfg.oprf.Noe);\n    }\n    serialize() {\n        return Array.from(this.data);\n    }\n    static sizeSerialized(cfg) {\n        return cfg.oprf.Noe;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        const start = 0;\n        const end = cfg.oprf.Noe;\n        const data = u8array.slice(start, end);\n        return new CredentialRequest(cfg, data);\n    }\n}\nclass CredentialResponse extends Serializable {\n    constructor(cfg, evaluation, masking_nonce, masked_response) {\n        Serializable.check_uint8arrays([masking_nonce, masked_response]);\n        super();\n        this.evaluation = evaluation;\n        this.masking_nonce = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(masking_nonce, cfg.constants.Nn);\n        this.masked_response = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(masked_response, cfg.ake.Npk + Envelope.sizeSerialized(cfg));\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.evaluation, this.masking_nonce, this.masked_response]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.oprf.Noe + cfg.constants.Nn + cfg.ake.Npk + Envelope.sizeSerialized(cfg);\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.oprf.Noe;\n        const evaluation_bytes = u8array.slice(start, end);\n        const evaluation = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(evaluation_bytes, cfg.oprf.Noe);\n        start = end;\n        end += cfg.constants.Nn;\n        const masking_nonce = u8array.slice(start, end);\n        start = end;\n        end += cfg.ake.Npk + Envelope.sizeSerialized(cfg);\n        const masked_response = u8array.slice(start, end);\n        return new CredentialResponse(cfg, evaluation, masking_nonce, masked_response);\n    }\n}\nclass CredentialFile extends Serializable {\n    constructor(credential_identifier, record, client_identity) {\n        if (!(Serializable.check_string(credential_identifier) &&\n            (client_identity ? Serializable.check_string(client_identity) : true))) {\n            throw new Error('expected string inputs');\n        }\n        super();\n        this.credential_identifier = credential_identifier;\n        this.record = record;\n        this.client_identity = client_identity;\n    }\n    serialize() {\n        const te = new TextEncoder();\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.encode_vector_16)(te.encode(this.credential_identifier)),\n            Uint8Array.from(this.record.serialize()),\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.encode_vector_16)(te.encode(this.client_identity))\n        ]));\n    }\n    static sizeSerialized(cfg) {\n        // This is the minimum size of a valid CredentialFile.\n        return (2 + // Size of header for credential_identifier.\n            RegistrationRecord.sizeSerialized(cfg) +\n            2 // Size of header for client_identity.\n        );\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        const td = new TextDecoder();\n        const res = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.decode_vector_16)(u8array);\n        const credential_identifier = td.decode(res.payload);\n        let start = 0;\n        let end = res.consumed;\n        start = end;\n        end += RegistrationRecord.sizeSerialized(cfg);\n        const record = RegistrationRecord.deserialize(cfg, Array.from(u8array.slice(start, end)));\n        start = end;\n        const { payload } = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.decode_vector_16)(u8array.slice(start));\n        const client_identity = payload.length === 0 ? undefined : td.decode(payload); // eslint-disable-line no-undefined\n        return new CredentialFile(credential_identifier, record, client_identity);\n    }\n}\nclass AuthInit extends Serializable {\n    constructor(cfg, client_nonce, client_keyshare) {\n        Serializable.check_uint8arrays([client_nonce, client_keyshare]);\n        super();\n        this.client_nonce = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(client_nonce, cfg.constants.Nn);\n        this.client_keyshare = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(client_keyshare, cfg.ake.Npk);\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.client_nonce, this.client_keyshare]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.constants.Nn + cfg.ake.Npk;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.constants.Nn;\n        const client_nonce = u8array.slice(start, end);\n        start = end;\n        end += cfg.ake.Npk;\n        const client_keyshare = u8array.slice(start, end);\n        return new AuthInit(cfg, client_nonce, client_keyshare);\n    }\n}\nclass AuthResponse extends Serializable {\n    constructor(cfg, server_nonce, server_keyshare, server_mac) {\n        Serializable.check_uint8arrays([server_nonce, server_keyshare, server_mac]);\n        super();\n        this.server_nonce = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(server_nonce, cfg.constants.Nn);\n        this.server_keyshare = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(server_keyshare, cfg.ake.Npk);\n        this.server_mac = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(server_mac, cfg.mac.Nm);\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.server_nonce, this.server_keyshare, this.server_mac]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.constants.Nn + cfg.ake.Npk + cfg.mac.Nm;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.constants.Nn;\n        const server_nonce = u8array.slice(start, end);\n        start = end;\n        end += cfg.ake.Npk;\n        const server_keyshare = u8array.slice(start, end);\n        start = end;\n        end += cfg.mac.Nm;\n        const server_mac = u8array.slice(start, end);\n        return new AuthResponse(cfg, server_nonce, server_keyshare, server_mac);\n    }\n}\nclass AuthFinish extends Serializable {\n    constructor(cfg, client_mac) {\n        Serializable.check_uint8array(client_mac);\n        super();\n        this.client_mac = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(client_mac, cfg.mac.Nm);\n    }\n    serialize() {\n        return Array.from(this.client_mac.slice());\n    }\n    static sizeSerialized(cfg) {\n        return cfg.mac.Nm;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        const start = 0;\n        const end = cfg.mac.Nm;\n        const client_mac = u8array.slice(start, end);\n        return new AuthFinish(cfg, client_mac);\n    }\n}\nclass ExpectedAuthResult extends Serializable {\n    constructor(cfg, expected_client_mac, session_key) {\n        Serializable.check_uint8arrays([expected_client_mac, session_key]);\n        super();\n        this.expected_client_mac = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(expected_client_mac, cfg.mac.Nm);\n        this.session_key = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.checked_vector)(session_key, cfg.kdf.Nx);\n    }\n    serialize() {\n        return Array.from((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([this.expected_client_mac, this.session_key]));\n    }\n    static sizeSerialized(cfg) {\n        return cfg.mac.Nm + cfg.kdf.Nx;\n    }\n    static deserialize(cfg, bytes) {\n        const u8array = this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = cfg.mac.Nm;\n        const expected_client_mac = u8array.slice(start, end);\n        start = end;\n        end += cfg.kdf.Nx;\n        const session_key = u8array.slice(start, end);\n        return new ExpectedAuthResult(cfg, expected_client_mac, session_key);\n    }\n}\nclass KE1 extends Serializable {\n    constructor(request, auth_init) {\n        super();\n        this.request = request;\n        this.auth_init = auth_init;\n    }\n    serialize() {\n        return [...this.request.serialize(), ...this.auth_init.serialize()];\n    }\n    static sizeSerialized(cfg) {\n        return CredentialRequest.sizeSerialized(cfg) + AuthInit.sizeSerialized(cfg);\n    }\n    static deserialize(cfg, bytes) {\n        this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = CredentialRequest.sizeSerialized(cfg);\n        const request = CredentialRequest.deserialize(cfg, bytes.slice(start, end));\n        start = end;\n        end += AuthInit.sizeSerialized(cfg);\n        const auth_init = AuthInit.deserialize(cfg, bytes.slice(start, end));\n        return new KE1(request, auth_init);\n    }\n}\nclass KE2 extends Serializable {\n    constructor(response, auth_response) {\n        super();\n        this.response = response;\n        this.auth_response = auth_response;\n    }\n    serialize() {\n        return [...this.response.serialize(), ...this.auth_response.serialize()];\n    }\n    static sizeSerialized(cfg) {\n        return CredentialResponse.sizeSerialized(cfg) + AuthResponse.sizeSerialized(cfg);\n    }\n    static deserialize(cfg, bytes) {\n        this.checked_bytes_to_uint8array(cfg, bytes);\n        let start = 0;\n        let end = CredentialResponse.sizeSerialized(cfg);\n        const response = CredentialResponse.deserialize(cfg, bytes.slice(start, end));\n        start = end;\n        end += AuthResponse.sizeSerialized(cfg);\n        const auth_response = AuthResponse.deserialize(cfg, bytes.slice(start, end));\n        return new KE2(response, auth_response);\n    }\n}\nclass KE3 extends Serializable {\n    constructor(auth_finish) {\n        super();\n        this.auth_finish = auth_finish;\n    }\n    serialize() {\n        return this.auth_finish.serialize();\n    }\n    static sizeSerialized(cfg) {\n        return AuthFinish.sizeSerialized(cfg);\n    }\n    static deserialize(cfg, bytes) {\n        this.checked_bytes_to_uint8array(cfg, bytes);\n        const start = 0;\n        const end = Number(AuthFinish.sizeSerialized(cfg));\n        const auth_finish = AuthFinish.deserialize(cfg, bytes.slice(start, end));\n        return new KE3(auth_finish);\n    }\n}\n//# sourceMappingURL=messages.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/messages.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/opaque_client.js"
/*!*********************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/opaque_client.js ***!
  \*********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueClient: () => (/* binding */ OpaqueClient)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thecrypto.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js\");\n/* harmony import */ var _3dh_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./3dh_client.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/3dh_client.js\");\n/* harmony import */ var _core_client_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core_client.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/core_client.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\n\nclass OpaqueClient {\n    constructor(config, memHard = _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__.ScryptMemHardFn) {\n        this.config = config;\n        this.status = OpaqueClient.States.NEW;\n        this.opaque_core = new _core_client_js__WEBPACK_IMPORTED_MODULE_3__.OpaqueCoreClient(config, memHard);\n        this.ake = new _3dh_client_js__WEBPACK_IMPORTED_MODULE_2__.AKE3DHClient(this.config);\n    }\n    async registerInit(password) {\n        if (this.status !== OpaqueClient.States.NEW) {\n            return new Error('client not ready');\n        }\n        const password_uint8array = new TextEncoder().encode(password);\n        const { request, blind } = await this.opaque_core.createRegistrationRequest(password_uint8array);\n        this.blind = blind;\n        this.password = password_uint8array;\n        this.status = OpaqueClient.States.REG_STARTED;\n        return request;\n    }\n    async registerFinish(response, server_identity, client_identity) {\n        if (this.status !== OpaqueClient.States.REG_STARTED ||\n            typeof this.password === 'undefined' ||\n            typeof this.blind === 'undefined') {\n            return new Error('client not ready');\n        }\n        const te = new TextEncoder();\n        // eslint-disable-next-line no-undefined\n        const server_identity_u8array = server_identity ? te.encode(server_identity) : undefined;\n        // eslint-disable-next-line no-undefined\n        const client_identity_u8array = client_identity ? te.encode(client_identity) : undefined;\n        const out = await this.opaque_core.finalizeRequest(this.password, this.blind, response, server_identity_u8array, client_identity_u8array);\n        this.clean();\n        return out;\n    }\n    async authInit(password) {\n        if (this.status !== OpaqueClient.States.NEW) {\n            return new Error('client not ready');\n        }\n        const password_u8array = new TextEncoder().encode(password);\n        const { request, blind } = await this.opaque_core.createCredentialRequest(password_u8array);\n        const auth_init = await this.ake.start();\n        const ke1 = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.KE1(request, auth_init);\n        this.blind = blind;\n        this.password = password_u8array;\n        this.ke1 = ke1;\n        this.status = OpaqueClient.States.LOG_STARTED;\n        return ke1;\n    }\n    async authFinish(ke2, server_identity, client_identity, context) {\n        if (this.status !== OpaqueClient.States.LOG_STARTED ||\n            typeof this.password === 'undefined' ||\n            typeof this.blind === 'undefined' ||\n            typeof this.ke1 === 'undefined') {\n            return new Error('client not ready');\n        }\n        const te = new TextEncoder();\n        // eslint-disable-next-line no-undefined\n        const server_identity_u8array = server_identity ? te.encode(server_identity) : undefined;\n        // eslint-disable-next-line no-undefined\n        const client_identity_u8array = client_identity ? te.encode(client_identity) : undefined;\n        const context_u8array = context ? te.encode(context) : new Uint8Array(0);\n        const rec = await this.opaque_core.recoverCredentials(this.password, this.blind, ke2.response, server_identity_u8array, client_identity_u8array);\n        if (rec instanceof Error) {\n            return rec;\n        }\n        const { client_ake_keypair, server_public_key, export_key } = rec;\n        const fin = await this.ake.finalize(client_identity_u8array ? client_identity_u8array : client_ake_keypair.public_key, client_ake_keypair.private_key, server_identity_u8array ? server_identity_u8array : server_public_key, server_public_key, this.ke1, ke2, context_u8array);\n        if (fin instanceof Error) {\n            return fin;\n        }\n        const { auth_finish, session_key } = fin;\n        const ke3 = new _messages_js__WEBPACK_IMPORTED_MODULE_0__.KE3(auth_finish);\n        this.clean();\n        return { ke3, session_key: Array.from(session_key), export_key: Array.from(export_key) };\n    }\n    clean() {\n        this.status = OpaqueClient.States.NEW;\n        this.password = undefined; // eslint-disable-line no-undefined\n        this.blind = undefined; // eslint-disable-line no-undefined\n        this.ke1 = undefined; // eslint-disable-line no-undefined\n    }\n}\nOpaqueClient.States = {\n    NEW: 0,\n    REG_STARTED: 1,\n    LOG_STARTED: 2\n};\n//# sourceMappingURL=opaque_client.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/opaque_client.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/opaque_server.js"
/*!*********************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/opaque_server.js ***!
  \*********************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueServer: () => (/* binding */ OpaqueServer)\n/* harmony export */ });\n/* harmony import */ var _messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/messages.js\");\n/* harmony import */ var _3dh_server_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./3dh_server.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/3dh_server.js\");\n/* harmony import */ var _core_server_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core_server.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/core_server.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nclass OpaqueServer {\n    constructor(config, oprf_seed, ake_keypair_export, server_identity) {\n        this.config = config;\n        _messages_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.check_bytes_arrays([\n            ake_keypair_export.public_key,\n            ake_keypair_export.private_key\n        ]);\n        this.ake_keypair = {\n            private_key: new Uint8Array(ake_keypair_export.private_key),\n            public_key: new Uint8Array(ake_keypair_export.public_key)\n        };\n        _messages_js__WEBPACK_IMPORTED_MODULE_0__.Serializable.check_bytes_array(oprf_seed);\n        this.server_identity = server_identity\n            ? new TextEncoder().encode(server_identity)\n            : this.ake_keypair.public_key;\n        this.opaque_core = new _core_server_js__WEBPACK_IMPORTED_MODULE_2__.OpaqueCoreServer(config, new Uint8Array(oprf_seed));\n        this.ake = new _3dh_server_js__WEBPACK_IMPORTED_MODULE_1__.AKE3DHServer(this.config);\n    }\n    registerInit(request, credential_identifier) {\n        return this.opaque_core.createRegistrationResponse(request, this.ake_keypair.public_key, new TextEncoder().encode(credential_identifier));\n    }\n    async authInit(ke1, record, credential_identifier, client_identity, context) {\n        const credential_identifier_u8array = new TextEncoder().encode(credential_identifier);\n        const response = await this.opaque_core.createCredentialResponse(ke1.request, record, this.ake_keypair.public_key, credential_identifier_u8array);\n        const te = new TextEncoder();\n        // eslint-disable-next-line no-undefined\n        const client_identity_u8array = client_identity ? te.encode(client_identity) : undefined;\n        const context_u8array = context ? te.encode(context) : new Uint8Array(0);\n        return this.ake.response(this.ake_keypair.private_key, this.server_identity, ke1, response, context_u8array, record.client_public_key, client_identity_u8array);\n    }\n    authFinish(ke3, expected) {\n        return this.ake.finish(ke3.auth_finish, expected);\n    }\n}\n//# sourceMappingURL=opaque_server.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/opaque_server.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/suites.js"
/*!**************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/suites.js ***!
  \**************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueID: () => (/* binding */ OpaqueID),\n/* harmony export */   getOpaqueConfig: () => (/* binding */ getOpaqueConfig)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/common.js\");\n/* harmony import */ var _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thecrypto.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js\");\n/* harmony import */ var _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cloudflare/voprf-ts */ \"./node_modules/@cloudflare/voprf-ts/lib/src/index.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nvar OpaqueID;\n(function (OpaqueID) {\n    OpaqueID[OpaqueID[\"OPAQUE_P256\"] = 3] = \"OPAQUE_P256\";\n    OpaqueID[OpaqueID[\"OPAQUE_P384\"] = 4] = \"OPAQUE_P384\";\n    OpaqueID[OpaqueID[\"OPAQUE_P521\"] = 5] = \"OPAQUE_P521\";\n})(OpaqueID || (OpaqueID = {}));\nclass OpaqueConfig {\n    constructor(opaqueID) {\n        this.opaqueID = opaqueID;\n        let oprfID = 0;\n        switch (opaqueID) {\n            case OpaqueID.OPAQUE_P256:\n                oprfID = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_2__.OprfID.OPRF_P256_SHA256;\n                break;\n            case OpaqueID.OPAQUE_P384:\n                oprfID = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_2__.OprfID.OPRF_P384_SHA384;\n                break;\n            case OpaqueID.OPAQUE_P521:\n                oprfID = _cloudflare_voprf_ts__WEBPACK_IMPORTED_MODULE_2__.OprfID.OPRF_P521_SHA512;\n                break;\n            default:\n                throw new Error('invalid opaque id');\n        }\n        this.constants = { Nn: 32, Nseed: 32 };\n        this.prng = new _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__.Prng();\n        this.oprf = new _common_js__WEBPACK_IMPORTED_MODULE_0__.OPRFBaseMode(oprfID);\n        this.hash = new _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__.Hash(this.oprf.hash);\n        this.mac = new _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__.Hmac(this.hash.name);\n        this.kdf = new _thecrypto_js__WEBPACK_IMPORTED_MODULE_1__.Hkdf(this.hash.name);\n        this.ake = new _common_js__WEBPACK_IMPORTED_MODULE_0__.AKE3DH(this.oprf.id);\n    }\n    toString() {\n        return (`${OpaqueID[this.opaqueID]} = {` +\n            `OPRF: ${this.oprf.name}, ` +\n            `Hash: ${this.hash.name}}`);\n    }\n}\nfunction getOpaqueConfig(opaqueID) {\n    return new OpaqueConfig(opaqueID);\n}\n//# sourceMappingURL=suites.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/suites.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js"
/*!*****************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   Hkdf: () => (/* binding */ Hkdf),\n/* harmony export */   Hmac: () => (/* binding */ Hmac),\n/* harmony export */   IdentityMemHardFn: () => (/* binding */ IdentityMemHardFn),\n/* harmony export */   Prng: () => (/* binding */ Prng),\n/* harmony export */   ScryptMemHardFn: () => (/* binding */ ScryptMemHardFn)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/opaque-ts/lib/src/util.js\");\n/* harmony import */ var _noble_hashes_lib_scrypt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/lib/scrypt */ \"./node_modules/@noble/hashes/lib/esm/scrypt.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nclass Prng {\n    /* eslint-disable-next-line class-methods-use-this */\n    random(numBytes) {\n        return Array.from(crypto.getRandomValues(new Uint8Array(numBytes)));\n    }\n}\nclass Hash {\n    constructor(name) {\n        this.name = name;\n        switch (name) {\n            case Hash.ID.SHA1:\n                this.Nh = 20;\n                break;\n            case Hash.ID.SHA256:\n                this.Nh = 32;\n                break;\n            case Hash.ID.SHA384:\n                this.Nh = 48;\n                break;\n            case Hash.ID.SHA512:\n                this.Nh = 64;\n                break;\n            default:\n                throw new Error(`invalid hash name: ${name}`);\n        }\n    }\n    async sum(msg) {\n        return new Uint8Array(await crypto.subtle.digest(this.name, msg));\n    }\n}\n/* eslint-disable-next-line @typescript-eslint/no-namespace */\n(function (Hash) {\n    Hash.ID = {\n        SHA1: 'SHA-1',\n        SHA256: 'SHA-256',\n        SHA384: 'SHA-384',\n        SHA512: 'SHA-512'\n    };\n})(Hash || (Hash = {}));\nclass Hmac {\n    constructor(hash) {\n        this.hash = hash;\n        this.Nm = new Hash(hash).Nh;\n    }\n    async with_key(key) {\n        return new Hmac.Macops(await crypto.subtle.importKey('raw', key, { name: 'HMAC', hash: this.hash }, false, [\n            'sign'\n        ]));\n    }\n}\nHmac.Macops = class {\n    constructor(crypto_key) {\n        this.crypto_key = crypto_key;\n    }\n    async sign(msg) {\n        return new Uint8Array(await crypto.subtle.sign(this.crypto_key.algorithm.name, this.crypto_key, msg));\n    }\n    async verify(msg, output) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.ctEqual)(output, await this.sign(msg));\n    }\n};\nclass Hkdf {\n    constructor(hash) {\n        this.hash = hash;\n        this.Nx = new Hmac(hash).Nm;\n    }\n    async extract(salt, ikm) {\n        return (await new Hmac(this.hash).with_key(salt)).sign(ikm);\n    }\n    async expand(prk, info, lenBytes) {\n        const hashLen = new Hash(this.hash).Nh;\n        const N = Math.ceil(lenBytes / hashLen);\n        const T = new Uint8Array(N * hashLen);\n        const hm = await new Hmac(this.hash).with_key(prk);\n        let Ti = new Uint8Array();\n        let offset = 0;\n        for (let i = 0; i < N; i++) {\n            Ti = await hm.sign((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([Ti, info, Uint8Array.of(i + 1)])); // eslint-disable-line no-await-in-loop\n            T.set(Ti, offset);\n            offset += hashLen;\n        }\n        return T.slice(0, lenBytes);\n    }\n}\nconst IdentityMemHardFn = { name: 'Identity', harden: (x) => x };\nconst ScryptMemHardFn = {\n    name: 'scrypt',\n    harden: (msg) => (0,_noble_hashes_lib_scrypt__WEBPACK_IMPORTED_MODULE_1__.scrypt)(msg, new Uint8Array(), { N: 32768, r: 8, p: 1 })\n};\n//# sourceMappingURL=thecrypto.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/thecrypto.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/opaque-ts/lib/src/util.js"
/*!************************************************************!*\
  !*** ./node_modules/@cloudflare/opaque-ts/lib/src/util.js ***!
  \************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checked_vector: () => (/* binding */ checked_vector),\n/* harmony export */   checked_vector_array: () => (/* binding */ checked_vector_array),\n/* harmony export */   ctEqual: () => (/* binding */ ctEqual),\n/* harmony export */   decode_vector_16: () => (/* binding */ decode_vector_16),\n/* harmony export */   encode_number: () => (/* binding */ encode_number),\n/* harmony export */   encode_vector_16: () => (/* binding */ encode_vector_16),\n/* harmony export */   encode_vector_8: () => (/* binding */ encode_vector_8),\n/* harmony export */   joinAll: () => (/* binding */ joinAll),\n/* harmony export */   xor: () => (/* binding */ xor)\n/* harmony export */ });\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\nfunction joinAll(a) {\n    let size = 0;\n    for (let i = 0; i < a.length; i++) {\n        size += a[i].length;\n    }\n    const ret = new Uint8Array(new ArrayBuffer(size));\n    for (let i = 0, offset = 0; i < a.length; i++) {\n        ret.set(a[i], offset);\n        offset += a[i].length;\n    }\n    return ret;\n}\nfunction encode_number(n, bits) {\n    if (!(bits > 0 && bits <= 32)) {\n        throw new Error('only supports 32-bit encoding');\n    }\n    const max = 1 << bits;\n    if (!(n >= 0 && n < max)) {\n        throw new Error(`number out of range [0,2^${bits}-1]`);\n    }\n    const numBytes = Math.ceil(bits / 8);\n    const out = new Uint8Array(numBytes);\n    for (let i = 0; i < numBytes; i++) {\n        out[(numBytes - 1 - i)] = (n >> (8 * i)) & 0xff;\n    }\n    return out;\n}\nfunction decode_number(a, bits) {\n    if (!(bits > 0 && bits <= 32)) {\n        throw new Error('only supports 32-bit encoding');\n    }\n    const numBytes = Math.ceil(bits / 8);\n    if (a.length !== numBytes) {\n        throw new Error('array has wrong size');\n    }\n    let out = 0;\n    for (let i = 0; i < a.length; i++) {\n        out <<= 8;\n        out += a[i];\n    }\n    return out;\n}\nfunction encode_vector(a, bits_header) {\n    return joinAll([encode_number(a.length, bits_header), a]);\n}\nfunction decode_vector(a, bits_header) {\n    if (a.length === 0) {\n        throw new Error('empty vector not allowed');\n    }\n    const numBytes = Math.ceil(bits_header / 8);\n    const header = a.subarray(0, numBytes);\n    const len = decode_number(header, bits_header);\n    const consumed = numBytes + len;\n    const payload = a.slice(numBytes, consumed);\n    return { payload, consumed };\n}\nfunction encode_vector_8(a) {\n    return encode_vector(a, 8);\n}\nfunction encode_vector_16(a) {\n    return encode_vector(a, 16);\n}\nfunction decode_vector_16(a) {\n    return decode_vector(a, 16);\n}\nfunction checked_vector(a, n, str = 'array') {\n    if (a.length < n) {\n        throw new Error(`${str} has wrong length`);\n    }\n    return a.slice(0, n);\n}\nfunction checked_vector_array(a, n, str = 'array') {\n    return checked_vector(Uint8Array.from(a), n, str);\n}\nfunction xor(a, b) {\n    if (a.length !== b.length || a.length === 0) {\n        throw new Error('arrays of different length');\n    }\n    const n = a.length;\n    const c = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n        c[i] = a[i] ^ b[i];\n    }\n    return c;\n}\nfunction ctEqual(a, b) {\n    if (a.length !== b.length || a.length === 0) {\n        throw new Error('arrays of different length');\n    }\n    const n = a.length;\n    let c = 0;\n    for (let i = 0; i < n; i++) {\n        c |= a[i] ^ b[i];\n    }\n    return c === 0;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/opaque-ts/lib/src/util.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/client.js"
/*!*************************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/client.js ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OPRFClient: () => (/* binding */ OPRFClient)\n/* harmony export */ });\n/* harmony import */ var _oprf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oprf.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/group.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nclass OPRFClient extends _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf {\n    async randomBlinder() {\n        const scalar = await this.params.gg.randomScalar(), blind = new _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Blind(this.params.gg.serializeScalar(scalar));\n        return { scalar, blind };\n    }\n    async blind(input) {\n        const { scalar, blind } = await this.randomBlinder(), dst = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.getHashToGroupDST(this.params.id), P = await this.params.gg.hashToGroup(input, dst), Q = _group_js__WEBPACK_IMPORTED_MODULE_1__.Group.mul(scalar, P), blindedElement = new _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Blinded(this.params.gg.serialize(Q));\n        return { blind, blindedElement };\n    }\n    finalize(input, info, blind, evaluation) {\n        const blindScalar = this.params.gg.deserializeScalar(blind), blindScalarInv = this.params.gg.invScalar(blindScalar), Z = this.params.gg.deserialize(evaluation), N = _group_js__WEBPACK_IMPORTED_MODULE_1__.Group.mul(blindScalarInv, Z), unblinded = this.params.gg.serialize(N);\n        return this.coreFinalize(input, info, unblinded);\n    }\n}\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/client.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/group.js"
/*!************************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/group.js ***!
  \************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Group: () => (/* binding */ Group),\n/* harmony export */   GroupID: () => (/* binding */ GroupID),\n/* harmony export */   SerializedElt: () => (/* binding */ SerializedElt),\n/* harmony export */   SerializedScalar: () => (/* binding */ SerializedScalar)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/util.js\");\n/* harmony import */ var _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sjcl/index.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/sjcl/index.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nclass SerializedElt extends Uint8Array {\n    constructor() {\n        super(...arguments);\n        this._serializedEltBrand = '';\n    }\n}\nclass SerializedScalar extends Uint8Array {\n    constructor() {\n        super(...arguments);\n        this._serializedScalarBrand = '';\n    }\n}\nasync function expandXMD(hash, msg, dst, numBytes) {\n    const { outLenBytes, blockLenBytes } = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.hashParams)(hash), ell = Math.ceil(numBytes / outLenBytes);\n    if (ell > 255) {\n        throw new Error('too big');\n    }\n    let dstPrime = dst;\n    if (dst.length > 255) {\n        const te = new TextEncoder(), input = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([te.encode('H2C-OVERSIZE-DST-'), dst]);\n        dstPrime = new Uint8Array(await crypto.subtle.digest(hash, input));\n    }\n    dstPrime = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([dstPrime, new Uint8Array([dstPrime.length])]);\n    const zPad = new Uint8Array(blockLenBytes), libStr = new Uint8Array(2);\n    libStr[0] = (numBytes >> 8) & 0xff;\n    libStr[1] = numBytes & 0xff;\n    const b0Input = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([zPad, msg, libStr, new Uint8Array([0]), dstPrime]), b0 = new Uint8Array(await crypto.subtle.digest(hash, b0Input)), b1Input = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([b0, new Uint8Array([1]), dstPrime]);\n    let bi = new Uint8Array(await crypto.subtle.digest(hash, b1Input)), pseudo = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([bi]);\n    for (let i = 2; i <= ell; i++) {\n        const biInput = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([(0,_util_js__WEBPACK_IMPORTED_MODULE_0__.xor)(bi, b0), new Uint8Array([i]), dstPrime]);\n        bi = new Uint8Array(await crypto.subtle.digest(hash, biInput)); // eslint-disable-line no-await-in-loop\n        pseudo = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.joinAll)([pseudo, bi]);\n    }\n    return pseudo.slice(0, numBytes);\n}\nvar GroupID;\n(function (GroupID) {\n    GroupID[\"P256\"] = \"P-256\";\n    GroupID[\"P384\"] = \"P-384\";\n    GroupID[\"P521\"] = \"P-521\";\n})(GroupID || (GroupID = {}));\n/* eslint new-cap: [\"error\", { \"properties\": false }] */\nclass Group {\n    constructor(gid) {\n        switch (gid) {\n            case GroupID.P256:\n                this.curve = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.curves.c256;\n                this.size = 32;\n                this.hashParams = {\n                    hash: 'SHA-256',\n                    L: 48,\n                    Z: -10,\n                    c2: '0x78bc71a02d89ec07214623f6d0f955072c7cc05604a5a6e23ffbf67115fa5301'\n                };\n                break;\n            case GroupID.P384:\n                this.curve = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.curves.c384;\n                this.size = 48;\n                this.hashParams = {\n                    hash: 'SHA-384',\n                    L: 72,\n                    Z: -12,\n                    c2: '0x19877cc1041b7555743c0ae2e3a3e61fb2aaa2e0e87ea557a563d8b598a0940d0a697a9e0b9e92cfaa314f583c9d066'\n                };\n                break;\n            case GroupID.P521:\n                this.curve = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.curves.c521;\n                this.size = 66;\n                this.hashParams = {\n                    hash: 'SHA-512',\n                    L: 98,\n                    Z: -4,\n                    c2: '0x8'\n                };\n                break;\n            default:\n                throw new Error(`group not implemented: ${gid}`);\n        }\n        this.id = gid;\n    }\n    static getID(id) {\n        switch (id) {\n            case 'P-256':\n                return GroupID.P256;\n            case 'P-384':\n                return GroupID.P384;\n            case 'P-521':\n                return GroupID.P521;\n            default:\n                throw new Error(`group not implemented: ${id}`);\n        }\n    }\n    identity() {\n        return new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.point(this.curve);\n    }\n    generator() {\n        return this.curve.G;\n    }\n    order() {\n        return this.curve.r;\n    }\n    // Serializes an element in uncompressed form.\n    serUnComp(e) {\n        const xy = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.arrayBuffer.fromBits(e.toBits(), false), bytes = new Uint8Array(xy);\n        if (bytes.length !== 2 * this.size) {\n            throw new Error('error serializing element');\n        }\n        const serElt = new SerializedElt(1 + 2 * this.size);\n        serElt[0] = 0x04;\n        serElt.set(bytes, 1);\n        return serElt;\n    }\n    // Serializes an element in compressed form.\n    serComp(e) {\n        const x = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.arrayBuffer.fromBits(e.x.toBits(), false), bytes = new Uint8Array(x), serElt = new SerializedElt(1 + this.size);\n        serElt[0] = 0x02 | (e.y.limbs[0] & 1);\n        serElt.set(bytes, 1 + this.size - bytes.length);\n        return serElt;\n    }\n    serialize(e, compressed = true) {\n        if (e.isIdentity) {\n            return new SerializedElt(1);\n        }\n        e.x.fullReduce();\n        e.y.fullReduce();\n        return compressed ? this.serComp(e) : this.serUnComp(e);\n    }\n    // Deserializes an element in compressed form.\n    deserComp(serElt) {\n        const array = Array.from(serElt.slice(1)), bytes = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.bytes.toBits(array), x = new this.curve.field(_sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn.fromBits(bytes)), p = this.curve.field.modulus, exp = p.add(new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(1)).halveM().halveM();\n        let y = x.square().add(this.curve.a).mul(x).add(this.curve.b).power(exp);\n        y.fullReduce();\n        if ((serElt[0] & 1) !== (y.limbs[0] & 1)) {\n            y = p.sub(y).mod(p);\n        }\n        const point = new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.point(this.curve, new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(x), new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(y));\n        if (!point.isValid()) {\n            throw new Error('point not in curve');\n        }\n        return point;\n    }\n    // Deserializes an element in uncompressed form.\n    deserUnComp(serElt) {\n        const array = Array.from(serElt.slice(1)), b = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.bytes.toBits(array), point = this.curve.fromBits(b);\n        point.x.fullReduce();\n        point.y.fullReduce();\n        return point;\n    }\n    // Deserializes an element, handles both compressed and uncompressed forms.\n    deserialize(serElt) {\n        const len = serElt.length;\n        switch (true) {\n            case len === 1 && serElt[0] === 0x00:\n                return this.identity();\n            case len === 1 + this.size && (serElt[0] === 0x02 || serElt[0] === 0x03):\n                return this.deserComp(serElt);\n            case len === 1 + 2 * this.size && serElt[0] === 0x04:\n                return this.deserUnComp(serElt);\n            default:\n                throw new Error('error deserializing element');\n        }\n    }\n    serializeScalar(s) {\n        const k = s.mod(this.curve.r);\n        k.normalize();\n        const ab = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.arrayBuffer.fromBits(k.toBits(), false), unpaded = new Uint8Array(ab), serScalar = new SerializedScalar(this.size);\n        serScalar.set(unpaded, this.size - unpaded.length);\n        return serScalar;\n    }\n    deserializeScalar(serScalar) {\n        const array = Array.from(serScalar), k = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn.fromBits(_sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.bytes.toBits(array));\n        k.normalize();\n        if (k.greaterEquals(this.curve.r)) {\n            throw new Error('error deserializing scalar');\n        }\n        return k;\n    }\n    addScalar(a, b) {\n        const c = a.add(b);\n        c.mod(this.curve.r);\n        c.normalize();\n        return c;\n    }\n    invScalar(k) {\n        return k.inverseMod(this.curve.r);\n    }\n    static mul(k, e) {\n        return e.mult(k);\n    }\n    mulBase(k) {\n        return this.curve.G.mult(k);\n    }\n    equal(a, b) {\n        if (this.curve !== a.curve || this.curve !== b.curve) {\n            return false;\n        }\n        if (a.isIdentity && b.isIdentity) {\n            return true;\n        }\n        return a.x.equals(b.x) && a.y.equals(b.y);\n    }\n    randomScalar() {\n        const msg = new Uint8Array(this.hashParams.L);\n        crypto.getRandomValues(msg);\n        return this.hashToScalar(msg, new Uint8Array());\n    }\n    async hashToScalar(msg, dst) {\n        const { hash, L } = this.hashParams, bytes = await expandXMD(hash, msg, dst, L), array = Array.from(bytes), bitArr = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.bytes.toBits(array), s = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn.fromBits(bitArr).mod(this.curve.r);\n        return s;\n    }\n    async hashToGroup(msg, dst) {\n        const u = await this.hashToField(msg, dst, 2), Q0 = this.sswu(u[0]), Q1 = this.sswu(u[1]);\n        return Q0.toJac().add(Q1).toAffine();\n    }\n    async hashToField(msg, dst, count) {\n        const { hash, L } = this.hashParams, bytes = await expandXMD(hash, msg, dst, count * L), u = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const j = i * L, array = Array.from(bytes.slice(j, j + L)), bitArr = _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].codec.bytes.toBits(array);\n            u[i] = new this.curve.field(_sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn.fromBits(bitArr));\n        }\n        return u;\n    }\n    sswu(u) {\n        const A = this.curve.a, B = this.curve.b, p = this.curve.field.modulus, Z = new this.curve.field(this.hashParams.Z), c2 = new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(this.hashParams.c2), c1 = p.sub(new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(3)).halveM().halveM(), // c1 = (p-3)/4\n        zero = new this.curve.field(0), one = new this.curve.field(1);\n        function sgn(x) {\n            x.fullReduce();\n            return x.limbs[0] & 1;\n        }\n        function cmov(x, y, b) {\n            return b ? y : x;\n        }\n        let tv1 = u.square(); //          1. tv1 = u^2\n        const tv3 = Z.mul(tv1); //        2. tv3 = Z * tv1\n        let tv2 = tv3.square(), //       3. tv2 = tv3^2\n        xd = tv2.add(tv3), //        4.  xd = tv2 + tv3\n        x1n = xd.add(one); //         5. x1n = xd + 1\n        x1n = x1n.mul(B); //              6. x1n = x1n * B\n        let tv4 = p.sub(A);\n        xd = xd.mul(tv4); //              7.  xd = -A * xd\n        const e1 = xd.equals(zero); //    8.  e1 = xd == 0\n        tv4 = A.mul(Z);\n        xd = cmov(xd, tv4, e1); //        9.  xd = CMOV(xd, Z * A, e1)\n        tv2 = xd.square(); //            10. tv2 = xd^2\n        const gxd = tv2.mul(xd); //      11. gxd = tv2 * xd\n        tv2 = tv2.mul(A); //             12. tv2 = A * tv2\n        let gx1 = x1n.square(); //       13. gx1 = x1n^2\n        gx1 = gx1.add(tv2); //           14. gx1 = gx1 + tv2\n        gx1 = gx1.mul(x1n); //           15. gx1 = gx1 * x1n\n        tv2 = gxd.mul(B); //             16. tv2 = B * gxd\n        gx1 = gx1.add(tv2); //           17. gx1 = gx1 + tv2\n        tv4 = gxd.square(); //           18. tv4 = gxd^2\n        tv2 = gx1.mul(gxd); //           19. tv2 = gx1 * gxd\n        tv4 = tv4.mul(tv2); //           20. tv4 = tv4 * tv2\n        let y1 = tv4.power(c1); //       21.  y1 = tv4^c1\n        y1 = y1.mul(tv2); //             22.  y1 = y1 * tv2\n        const x2n = tv3.mul(x1n); //     23. x2n = tv3 * x1n\n        let y2 = y1.mul(c2); //          24.  y2 = y1 * c2\n        y2 = y2.mul(tv1); //             25.  y2 = y2 * tv1\n        y2 = y2.mul(u); //               26.  y2 = y2 * u\n        tv2 = y1.square(); //            27. tv2 = y1^2\n        tv2 = tv2.mul(gxd); //           28. tv2 = tv2 * gxd\n        const e2 = tv2.equals(gx1), //  29.  e2 = tv2 == gx1\n        xn = cmov(x2n, x1n, e2); //  30.  xn = CMOV(x2n, x1n, e2)\n        let y = cmov(y2, y1, e2); //     31.   y = CMOV(y2, y1, e2)\n        const e3 = sgn(u) === sgn(y); // 32.  e3 = sgn0(u) == sgn0(y)\n        tv1 = p.sub(y);\n        y = cmov(tv1, y, e3); //         33.   y = CMOV(-y, y, e3)\n        let x = xd.inverseMod(p); //     34. return (xn, xd, y, 1)\n        x = xn.mul(x);\n        const point = new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ecc.point(this.curve, new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(x), new _sjcl_index_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].bn(y));\n        if (!point.isValid()) {\n            throw new Error('point not in curve');\n        }\n        return point;\n    }\n}\nGroup.paranoia = 6;\n//# sourceMappingURL=group.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/group.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/index.js"
/*!************************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/index.js ***!
  \************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blind: () => (/* reexport safe */ _oprf_js__WEBPACK_IMPORTED_MODULE_1__.Blind),\n/* harmony export */   Blinded: () => (/* reexport safe */ _oprf_js__WEBPACK_IMPORTED_MODULE_1__.Blinded),\n/* harmony export */   Evaluation: () => (/* reexport safe */ _oprf_js__WEBPACK_IMPORTED_MODULE_1__.Evaluation),\n/* harmony export */   Group: () => (/* reexport safe */ _group_js__WEBPACK_IMPORTED_MODULE_0__.Group),\n/* harmony export */   GroupID: () => (/* reexport safe */ _group_js__WEBPACK_IMPORTED_MODULE_0__.GroupID),\n/* harmony export */   OPRFClient: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_2__.OPRFClient),\n/* harmony export */   OPRFServer: () => (/* reexport safe */ _server_js__WEBPACK_IMPORTED_MODULE_3__.OPRFServer),\n/* harmony export */   Oprf: () => (/* reexport safe */ _oprf_js__WEBPACK_IMPORTED_MODULE_1__.Oprf),\n/* harmony export */   OprfID: () => (/* reexport safe */ _oprf_js__WEBPACK_IMPORTED_MODULE_1__.OprfID),\n/* harmony export */   SerializedElt: () => (/* reexport safe */ _group_js__WEBPACK_IMPORTED_MODULE_0__.SerializedElt),\n/* harmony export */   SerializedScalar: () => (/* reexport safe */ _group_js__WEBPACK_IMPORTED_MODULE_0__.SerializedScalar),\n/* harmony export */   deriveKeyPair: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.deriveKeyPair),\n/* harmony export */   derivePrivateKey: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.derivePrivateKey),\n/* harmony export */   generateKeyPair: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.generateKeyPair),\n/* harmony export */   generatePublicKey: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.generatePublicKey),\n/* harmony export */   getKeySizes: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.getKeySizes),\n/* harmony export */   randomPrivateKey: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.randomPrivateKey),\n/* harmony export */   validatePrivateKey: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.validatePrivateKey),\n/* harmony export */   validatePublicKey: () => (/* reexport safe */ _keys_js__WEBPACK_IMPORTED_MODULE_4__.validatePublicKey)\n/* harmony export */ });\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/group.js\");\n/* harmony import */ var _oprf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./oprf.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js\");\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./client.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/client.js\");\n/* harmony import */ var _server_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./server.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/server.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/keys.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/index.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/keys.js"
/*!***********************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/keys.js ***!
  \***********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deriveKeyPair: () => (/* binding */ deriveKeyPair),\n/* harmony export */   derivePrivateKey: () => (/* binding */ derivePrivateKey),\n/* harmony export */   generateKeyPair: () => (/* binding */ generateKeyPair),\n/* harmony export */   generatePublicKey: () => (/* binding */ generatePublicKey),\n/* harmony export */   getKeySizes: () => (/* binding */ getKeySizes),\n/* harmony export */   randomPrivateKey: () => (/* binding */ randomPrivateKey),\n/* harmony export */   validatePrivateKey: () => (/* binding */ validatePrivateKey),\n/* harmony export */   validatePublicKey: () => (/* binding */ validatePublicKey)\n/* harmony export */ });\n/* harmony import */ var _oprf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oprf.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/group.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nfunction getKeySizes(id) {\n    const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id);\n    return { Nsk: gg.size, Npk: 1 + gg.size };\n}\nfunction validatePrivateKey(id, privateKey) {\n    try {\n        const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id), s = gg.deserializeScalar(new _group_js__WEBPACK_IMPORTED_MODULE_1__.SerializedScalar(privateKey));\n        return !s.equals(0);\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction validatePublicKey(id, publicKey) {\n    try {\n        const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id), P = gg.deserialize(new _group_js__WEBPACK_IMPORTED_MODULE_1__.SerializedElt(publicKey));\n        return !P.isIdentity;\n    }\n    catch (_) {\n        return false;\n    }\n}\nasync function randomPrivateKey(id) {\n    const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id), priv = await gg.randomScalar();\n    return new Uint8Array(gg.serializeScalar(priv));\n}\nasync function derivePrivateKey(id, seed) {\n    const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id), priv = await gg.hashToScalar(seed, _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.getHashToScalarDST(id));\n    return new Uint8Array(gg.serializeScalar(priv));\n}\nfunction generatePublicKey(id, privateKey) {\n    const { gg } = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.params(id), priv = gg.deserializeScalar(new _group_js__WEBPACK_IMPORTED_MODULE_1__.SerializedScalar(privateKey)), pub = gg.mulBase(priv);\n    return new Uint8Array(gg.serialize(pub));\n}\nasync function generateKeyPair(id) {\n    const privateKey = await randomPrivateKey(id), publicKey = generatePublicKey(id, privateKey);\n    return { privateKey, publicKey };\n}\nasync function deriveKeyPair(id, seed) {\n    const privateKey = await derivePrivateKey(id, seed), publicKey = generatePublicKey(id, privateKey);\n    return { privateKey, publicKey };\n}\n//# sourceMappingURL=keys.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/keys.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js"
/*!***********************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js ***!
  \***********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blind: () => (/* binding */ Blind),\n/* harmony export */   Blinded: () => (/* binding */ Blinded),\n/* harmony export */   Evaluation: () => (/* binding */ Evaluation),\n/* harmony export */   Oprf: () => (/* binding */ Oprf),\n/* harmony export */   OprfID: () => (/* binding */ OprfID)\n/* harmony export */ });\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/group.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/util.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\nclass Blind extends _group_js__WEBPACK_IMPORTED_MODULE_0__.SerializedScalar {\n    constructor() {\n        super(...arguments);\n        this._BlindBrand = '';\n    }\n}\nclass Blinded extends _group_js__WEBPACK_IMPORTED_MODULE_0__.SerializedElt {\n    constructor() {\n        super(...arguments);\n        this._BlindedBrand = '';\n    }\n}\nclass Evaluation extends _group_js__WEBPACK_IMPORTED_MODULE_0__.SerializedElt {\n    constructor() {\n        super(...arguments);\n        this._EvaluationBrand = '';\n    }\n}\nvar OprfID;\n(function (OprfID) {\n    OprfID[OprfID[\"OPRF_P256_SHA256\"] = 3] = \"OPRF_P256_SHA256\";\n    OprfID[OprfID[\"OPRF_P384_SHA384\"] = 4] = \"OPRF_P384_SHA384\";\n    OprfID[OprfID[\"OPRF_P521_SHA512\"] = 5] = \"OPRF_P521_SHA512\";\n})(OprfID || (OprfID = {}));\nclass Oprf {\n    constructor(id) {\n        this.params = Oprf.params(id);\n    }\n    static validateID(id) {\n        switch (id) {\n            case OprfID.OPRF_P256_SHA256:\n            case OprfID.OPRF_P384_SHA384:\n            case OprfID.OPRF_P521_SHA512:\n                return true;\n            default:\n                throw new Error(`not supported ID: ${id}`);\n        }\n    }\n    static params(id) {\n        Oprf.validateID(id);\n        let gid = _group_js__WEBPACK_IMPORTED_MODULE_0__.GroupID.P256, hash = 'SHA-256';\n        switch (id) {\n            case OprfID.OPRF_P256_SHA256:\n                break;\n            case OprfID.OPRF_P384_SHA384:\n                gid = _group_js__WEBPACK_IMPORTED_MODULE_0__.GroupID.P384;\n                hash = 'SHA-384';\n                break;\n            case OprfID.OPRF_P521_SHA512:\n                gid = _group_js__WEBPACK_IMPORTED_MODULE_0__.GroupID.P521;\n                hash = 'SHA-512';\n                break;\n            default:\n                throw new Error(`not supported ID: ${id}`);\n        }\n        const gg = new _group_js__WEBPACK_IMPORTED_MODULE_0__.Group(gid);\n        return {\n            id,\n            gg,\n            hash,\n            blindedSize: 1 + gg.size,\n            evaluationSize: 1 + gg.size,\n            blindSize: gg.size\n        };\n    }\n    static getContextString(id) {\n        Oprf.validateID(id);\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([new TextEncoder().encode(Oprf.version), new Uint8Array([Oprf.mode, 0, id])]);\n    }\n    static getHashToGroupDST(id) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([new TextEncoder().encode('HashToGroup-'), Oprf.getContextString(id)]);\n    }\n    static getHashToScalarDST(id) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([new TextEncoder().encode('HashToScalar-'), Oprf.getContextString(id)]);\n    }\n    static getEvalContext(id, info) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([\n            new TextEncoder().encode('Context-'),\n            Oprf.getContextString(id),\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.to16bits)(info.length),\n            info\n        ]);\n    }\n    async coreFinalize(input, info, unblindedElement) {\n        const finalizeDST = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([\n            new TextEncoder().encode('Finalize-'),\n            Oprf.getContextString(this.params.id)\n        ]), hashInput = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.joinAll)([\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.to16bits)(input.length),\n            input,\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.to16bits)(info.length),\n            info,\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.to16bits)(unblindedElement.length),\n            unblindedElement,\n            (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.to16bits)(finalizeDST.length),\n            finalizeDST\n        ]);\n        return new Uint8Array(await crypto.subtle.digest(this.params.hash, hashInput));\n    }\n}\nOprf.mode = 0;\nOprf.version = 'VOPRF08-';\n//# sourceMappingURL=oprf.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/server.js"
/*!*************************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/server.js ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OPRFServer: () => (/* binding */ OPRFServer)\n/* harmony export */ });\n/* harmony import */ var _oprf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./oprf.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/oprf.js\");\n/* harmony import */ var _group_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./group.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/group.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"./node_modules/@cloudflare/voprf-ts/lib/src/util.js\");\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\n\n\n\nclass OPRFServer extends _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf {\n    constructor(id, privateKey) {\n        super(id);\n        this.supportsWebCryptoOPRF = false;\n        this.privateKey = privateKey;\n    }\n    async evaluate(blindedElement, info) {\n        const context = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.getEvalContext(this.params.id, info), dst = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.getHashToScalarDST(this.params.id), m = await this.params.gg.hashToScalar(context, dst), serSk = new _group_js__WEBPACK_IMPORTED_MODULE_1__.SerializedScalar(this.privateKey), sk = this.params.gg.deserializeScalar(serSk), t = this.params.gg.addScalar(sk, m), tInv = this.params.gg.invScalar(t);\n        if (this.supportsWebCryptoOPRF) {\n            const serTInv = this.params.gg.serializeScalar(tInv);\n            return this.evaluateWebCrypto(blindedElement, serTInv);\n        }\n        return Promise.resolve(this.evaluateSJCL(blindedElement, tInv));\n    }\n    async evaluateWebCrypto(blindedElement, secret) {\n        const key = await crypto.subtle.importKey('raw', secret, {\n            name: 'OPRF',\n            namedCurve: this.params.gg.id\n        }, true, ['sign']);\n        // webcrypto accepts only compressed points.\n        let compressed = Uint8Array.from(blindedElement);\n        if (blindedElement[0] === 0x04) {\n            const P = this.params.gg.deserialize(blindedElement);\n            compressed = Uint8Array.from(this.params.gg.serialize(P, true));\n        }\n        const evaluation = await crypto.subtle.sign('OPRF', key, compressed);\n        return new _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Evaluation(evaluation);\n    }\n    evaluateSJCL(blindedElement, secret) {\n        const P = this.params.gg.deserialize(blindedElement), Z = _group_js__WEBPACK_IMPORTED_MODULE_1__.Group.mul(secret, P);\n        return new _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Evaluation(this.params.gg.serialize(Z));\n    }\n    async fullEvaluate(input, info) {\n        const dst = _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Oprf.getHashToGroupDST(this.params.id), T = await this.params.gg.hashToGroup(input, dst), issuedElement = new _oprf_js__WEBPACK_IMPORTED_MODULE_0__.Blinded(this.params.gg.serialize(T)), evaluation = await this.evaluate(issuedElement, info), digest = await this.coreFinalize(input, info, evaluation);\n        return digest;\n    }\n    async verifyFinalize(input, output, info) {\n        const digest = await this.fullEvaluate(input, info);\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.ctEqual)(output, digest);\n    }\n}\n//# sourceMappingURL=server.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/server.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/sjcl/index.js"
/*!*****************************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/sjcl/index.js ***!
  \*****************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/** @fileOverview Javascript cryptography implementation.\n *\n * Crush to remove comments, shorten variable names and\n * generally reduce transmission size.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n\n/*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */\n/*global document, window, escape, unescape, module, require, Uint32Array */\n/**\n * The Stanford Javascript Crypto Library, top-level namespace.\n * @namespace\n */\nvar sjcl = {\n    /**\n     * Symmetric ciphers.\n     * @namespace\n     */\n    cipher: {},\n    /**\n     * Hash functions.  Right now only SHA256 is implemented.\n     * @namespace\n     */\n    hash: {},\n    /**\n     * Key exchange functions.  Right now only SRP is implemented.\n     * @namespace\n     */\n    keyexchange: {},\n    /**\n     * Cipher modes of operation.\n     * @namespace\n     */\n    mode: {},\n    /**\n     * Miscellaneous.  HMAC and PBKDF2.\n     * @namespace\n     */\n    misc: {},\n    /**\n     * Bit array encoders and decoders.\n     * @namespace\n     *\n     * @description\n     * The members of this namespace are functions which translate between\n     * SJCL's bitArrays and other objects (usually strings).  Because it\n     * isn't always clear which direction is encoding and which is decoding,\n     * the method names are \"fromBits\" and \"toBits\".\n     */\n    codec: {},\n    /**\n     * Exceptions.\n     * @namespace\n     */\n    exception: {\n        /**\n         * Ciphertext is corrupt.\n         * @constructor\n         */\n        corrupt: function (message) {\n            this.toString = function () { return \"CORRUPT: \" + this.message; };\n            this.message = message;\n        },\n        /**\n         * Invalid parameter.\n         * @constructor\n         */\n        invalid: function (message) {\n            this.toString = function () { return \"INVALID: \" + this.message; };\n            this.message = message;\n        },\n        /**\n         * Bug or missing feature in SJCL.\n         * @constructor\n         */\n        bug: function (message) {\n            this.toString = function () { return \"BUG: \" + this.message; };\n            this.message = message;\n        },\n        /**\n         * Something isn't ready.\n         * @constructor\n         */\n        notReady: function (message) {\n            this.toString = function () { return \"NOT READY: \" + this.message; };\n            this.message = message;\n        }\n    }\n};\n/** @fileOverview Low-level AES implementation.\n *\n * This file contains a low-level implementation of AES, optimized for\n * size and for efficiency on several browsers.  It is based on\n * OpenSSL's aes_core.c, a public-domain implementation by Vincent\n * Rijmen, Antoon Bosselaers and Paulo Barreto.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Schedule out an AES key for both encryption and decryption.  This\n * is a low-level class.  Use a cipher mode to do bulk encryption.\n *\n * @constructor\n * @param {Array} key The key as an array of 4, 6 or 8 words.\n */\nsjcl.cipher.aes = function (key) {\n    if (!this._tables[0][0][0]) {\n        this._precompute();\n    }\n    var i, j, tmp, encKey, decKey, sbox = this._tables[0][4], decTable = this._tables[1], keyLen = key.length, rcon = 1;\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n        throw new sjcl.exception.invalid(\"invalid aes key size\");\n    }\n    this._key = [encKey = key.slice(0), decKey = []];\n    // schedule encryption keys\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n        tmp = encKey[i - 1];\n        // apply sbox\n        if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {\n            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];\n            // shift rows and add rcon\n            if (i % keyLen === 0) {\n                tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;\n                rcon = rcon << 1 ^ (rcon >> 7) * 283;\n            }\n        }\n        encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n    // schedule decryption keys\n    for (j = 0; i; j++, i--) {\n        tmp = encKey[j & 3 ? i : i - 4];\n        if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n        }\n        else {\n            decKey[j] = decTable[0][sbox[tmp >>> 24]] ^\n                decTable[1][sbox[tmp >> 16 & 255]] ^\n                decTable[2][sbox[tmp >> 8 & 255]] ^\n                decTable[3][sbox[tmp & 255]];\n        }\n    }\n};\nsjcl.cipher.aes.prototype = {\n    // public\n    /* Something like this might appear here eventually\n    name: \"AES\",\n    blockSize: 4,\n    keySizes: [4,6,8],\n    */\n    /**\n     * Encrypt an array of 4 big-endian words.\n     * @param {Array} data The plaintext.\n     * @return {Array} The ciphertext.\n     */\n    encrypt: function (data) { return this._crypt(data, 0); },\n    /**\n     * Decrypt an array of 4 big-endian words.\n     * @param {Array} data The ciphertext.\n     * @return {Array} The plaintext.\n     */\n    decrypt: function (data) { return this._crypt(data, 1); },\n    /**\n     * The expanded S-box and inverse S-box tables.  These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    _tables: [[[], [], [], [], []], [[], [], [], [], []]],\n    /**\n     * Expand the S-box tables.\n     *\n     * @private\n     */\n    _precompute: function () {\n        var encTable = this._tables[0], decTable = this._tables[1], sbox = encTable[4], sboxInv = decTable[4], i, x, xInv, d = [], th = [], x2, x4, x8, s, tEnc, tDec;\n        // Compute double and third tables\n        for (i = 0; i < 256; i++) {\n            th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;\n        }\n        for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n            // Compute sbox\n            s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;\n            s = s >> 8 ^ s & 255 ^ 99;\n            sbox[x] = s;\n            sboxInv[s] = x;\n            // Compute MixColumns\n            x8 = d[x4 = d[x2 = d[x]]];\n            tDec = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n            tEnc = d[s] * 0x101 ^ s * 0x1010100;\n            for (i = 0; i < 4; i++) {\n                encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;\n                decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;\n            }\n        }\n        // Compactify.  Considerable speedup on Firefox.\n        for (i = 0; i < 5; i++) {\n            encTable[i] = encTable[i].slice(0);\n            decTable[i] = decTable[i].slice(0);\n        }\n    },\n    /**\n     * Encryption and decryption core.\n     * @param {Array} input Four words to be encrypted or decrypted.\n     * @param dir The direction, 0 for encrypt and 1 for decrypt.\n     * @return {Array} The four encrypted or decrypted words.\n     * @private\n     */\n    _crypt: function (input, dir) {\n        if (input.length !== 4) {\n            throw new sjcl.exception.invalid(\"invalid aes block size\");\n        }\n        var key = this._key[dir], \n        // state variables a,b,c,d are loaded with pre-whitened data\n        a = input[0] ^ key[0], b = input[dir ? 3 : 1] ^ key[1], c = input[2] ^ key[2], d = input[dir ? 1 : 3] ^ key[3], a2, b2, c2, nInnerRounds = key.length / 4 - 2, i, kIndex = 4, out = [0, 0, 0, 0], table = this._tables[dir], \n        // load up the tables\n        t0 = table[0], t1 = table[1], t2 = table[2], t3 = table[3], sbox = table[4];\n        // Inner rounds.  Cribbed from OpenSSL.\n        for (i = 0; i < nInnerRounds; i++) {\n            a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];\n            b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];\n            c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];\n            d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];\n            kIndex += 4;\n            a = a2;\n            b = b2;\n            c = c2;\n        }\n        // Last round.\n        for (i = 0; i < 4; i++) {\n            out[dir ? 3 & -i : i] =\n                sbox[a >>> 24] << 24 ^\n                    sbox[b >> 16 & 255] << 16 ^\n                    sbox[c >> 8 & 255] << 8 ^\n                    sbox[d & 255] ^\n                    key[kIndex++];\n            a2 = a;\n            a = b;\n            b = c;\n            c = d;\n            d = a2;\n        }\n        return out;\n    }\n};\n/** @fileOverview Arrays of bits, encoded as arrays of Numbers.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Arrays of bits, encoded as arrays of Numbers.\n * @namespace\n * @description\n * <p>\n * These objects are the currency accepted by SJCL's crypto functions.\n * </p>\n *\n * <p>\n * Most of our crypto primitives operate on arrays of 4-byte words internally,\n * but many of them can take arguments that are not a multiple of 4 bytes.\n * This library encodes arrays of bits (whose size need not be a multiple of 8\n * bits) as arrays of 32-bit words.  The bits are packed, big-endian, into an\n * array of words, 32 bits at a time.  Since the words are double-precision\n * floating point numbers, they fit some extra data.  We use this (in a private,\n * possibly-changing manner) to encode the number of bits actually  present\n * in the last word of the array.\n * </p>\n *\n * <p>\n * Because bitwise ops clear this out-of-band data, these arrays can be passed\n * to ciphers like AES which want arrays of words.\n * </p>\n */\nsjcl.bitArray = {\n    /**\n     * Array slices in units of bits.\n     * @param {bitArray} a The array to slice.\n     * @param {Number} bstart The offset to the start of the slice, in bits.\n     * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,\n     * slice until the end of the array.\n     * @return {bitArray} The requested slice.\n     */\n    bitSlice: function (a, bstart, bend) {\n        a = sjcl.bitArray._shiftRight(a.slice(bstart / 32), 32 - (bstart & 31)).slice(1);\n        return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend - bstart);\n    },\n    /**\n     * Extract a number packed into a bit array.\n     * @param {bitArray} a The array to slice.\n     * @param {Number} bstart The offset to the start of the slice, in bits.\n     * @param {Number} blength The length of the number to extract.\n     * @return {Number} The requested slice.\n     */\n    extract: function (a, bstart, blength) {\n        // FIXME: this Math.floor is not necessary at all, but for some reason\n        // seems to suppress a bug in the Chromium JIT.\n        var x, sh = Math.floor((-bstart - blength) & 31);\n        if ((bstart + blength - 1 ^ bstart) & -32) {\n            // it crosses a boundary\n            x = (a[bstart / 32 | 0] << (32 - sh)) ^ (a[bstart / 32 + 1 | 0] >>> sh);\n        }\n        else {\n            // within a single word\n            x = a[bstart / 32 | 0] >>> sh;\n        }\n        return x & ((1 << blength) - 1);\n    },\n    /**\n     * Concatenate two bit arrays.\n     * @param {bitArray} a1 The first array.\n     * @param {bitArray} a2 The second array.\n     * @return {bitArray} The concatenation of a1 and a2.\n     */\n    concat: function (a1, a2) {\n        if (a1.length === 0 || a2.length === 0) {\n            return a1.concat(a2);\n        }\n        var last = a1[a1.length - 1], shift = sjcl.bitArray.getPartial(last);\n        if (shift === 32) {\n            return a1.concat(a2);\n        }\n        else {\n            return sjcl.bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));\n        }\n    },\n    /**\n     * Find the length of an array of bits.\n     * @param {bitArray} a The array.\n     * @return {Number} The length of a, in bits.\n     */\n    bitLength: function (a) {\n        var l = a.length, x;\n        if (l === 0) {\n            return 0;\n        }\n        x = a[l - 1];\n        return (l - 1) * 32 + sjcl.bitArray.getPartial(x);\n    },\n    /**\n     * Truncate an array.\n     * @param {bitArray} a The array.\n     * @param {Number} len The length to truncate to, in bits.\n     * @return {bitArray} A new array, truncated to len bits.\n     */\n    clamp: function (a, len) {\n        if (a.length * 32 < len) {\n            return a;\n        }\n        a = a.slice(0, Math.ceil(len / 32));\n        var l = a.length;\n        len = len & 31;\n        if (l > 0 && len) {\n            a[l - 1] = sjcl.bitArray.partial(len, a[l - 1] & 0x80000000 >> (len - 1), 1);\n        }\n        return a;\n    },\n    /**\n     * Make a partial word for a bit array.\n     * @param {Number} len The number of bits in the word.\n     * @param {Number} x The bits.\n     * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.\n     * @return {Number} The partial word.\n     */\n    partial: function (len, x, _end) {\n        if (len === 32) {\n            return x;\n        }\n        return (_end ? x | 0 : x << (32 - len)) + len * 0x10000000000;\n    },\n    /**\n     * Get the number of bits used by a partial word.\n     * @param {Number} x The partial word.\n     * @return {Number} The number of bits used by the partial word.\n     */\n    getPartial: function (x) {\n        return Math.round(x / 0x10000000000) || 32;\n    },\n    /**\n     * Compare two arrays for equality in a predictable amount of time.\n     * @param {bitArray} a The first array.\n     * @param {bitArray} b The second array.\n     * @return {boolean} true if a == b; false otherwise.\n     */\n    equal: function (a, b) {\n        if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {\n            return false;\n        }\n        var x = 0, i;\n        for (i = 0; i < a.length; i++) {\n            x |= a[i] ^ b[i];\n        }\n        return (x === 0);\n    },\n    /** Shift an array right.\n     * @param {bitArray} a The array to shift.\n     * @param {Number} shift The number of bits to shift.\n     * @param {Number} [carry=0] A byte to carry in\n     * @param {bitArray} [out=[]] An array to prepend to the output.\n     * @private\n     */\n    _shiftRight: function (a, shift, carry, out) {\n        var i, last2 = 0, shift2;\n        if (out === undefined) {\n            out = [];\n        }\n        for (; shift >= 32; shift -= 32) {\n            out.push(carry);\n            carry = 0;\n        }\n        if (shift === 0) {\n            return out.concat(a);\n        }\n        for (i = 0; i < a.length; i++) {\n            out.push(carry | a[i] >>> shift);\n            carry = a[i] << (32 - shift);\n        }\n        last2 = a.length ? a[a.length - 1] : 0;\n        shift2 = sjcl.bitArray.getPartial(last2);\n        out.push(sjcl.bitArray.partial(shift + shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(), 1));\n        return out;\n    },\n    /** xor a block of 4 words together.\n     * @private\n     */\n    _xor4: function (x, y) {\n        return [x[0] ^ y[0], x[1] ^ y[1], x[2] ^ y[2], x[3] ^ y[3]];\n    },\n    /** byteswap a word array inplace.\n     * (does not handle partial words)\n     * @param {sjcl.bitArray} a word array\n     * @return {sjcl.bitArray} byteswapped array\n     */\n    byteswapM: function (a) {\n        var i, v, m = 0xff00;\n        for (i = 0; i < a.length; ++i) {\n            v = a[i];\n            a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);\n        }\n        return a;\n    }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * UTF-8 strings\n * @namespace\n */\nsjcl.codec.utf8String = {\n    /** Convert from a bitArray to a UTF-8 string. */\n    fromBits: function (arr) {\n        var out = \"\", bl = sjcl.bitArray.bitLength(arr), i, tmp;\n        for (i = 0; i < bl / 8; i++) {\n            if ((i & 3) === 0) {\n                tmp = arr[i / 4];\n            }\n            out += String.fromCharCode(tmp >>> 8 >>> 8 >>> 8);\n            tmp <<= 8;\n        }\n        return decodeURIComponent(escape(out));\n    },\n    /** Convert from a UTF-8 string to a bitArray. */\n    toBits: function (str) {\n        str = unescape(encodeURIComponent(str));\n        var out = [], i, tmp = 0;\n        for (i = 0; i < str.length; i++) {\n            tmp = tmp << 8 | str.charCodeAt(i);\n            if ((i & 3) === 3) {\n                out.push(tmp);\n                tmp = 0;\n            }\n        }\n        if (i & 3) {\n            out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n        }\n        return out;\n    }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Hexadecimal\n * @namespace\n */\nsjcl.codec.hex = {\n    /** Convert from a bitArray to a hex string. */\n    fromBits: function (arr) {\n        var out = \"\", i;\n        for (i = 0; i < arr.length; i++) {\n            out += ((arr[i] | 0) + 0xF00000000000).toString(16).substr(4);\n        }\n        return out.substr(0, sjcl.bitArray.bitLength(arr) / 4); //.replace(/(.{8})/g, \"$1 \");\n    },\n    /** Convert from a hex string to a bitArray. */\n    toBits: function (str) {\n        var i, out = [], len;\n        str = str.replace(/\\s|0x/g, \"\");\n        len = str.length;\n        str = str + \"00000000\";\n        for (i = 0; i < str.length; i += 8) {\n            out.push(parseInt(str.substr(i, 8), 16) ^ 0);\n        }\n        return sjcl.bitArray.clamp(out, len * 4);\n    }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Base64 encoding/decoding\n * @namespace\n */\nsjcl.codec.base64 = {\n    /** The base64 alphabet.\n     * @private\n     */\n    _chars: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n    /** Convert from a bitArray to a base64 string. */\n    fromBits: function (arr, _noEquals, _url) {\n        var out = \"\", i, bits = 0, c = sjcl.codec.base64._chars, ta = 0, bl = sjcl.bitArray.bitLength(arr);\n        if (_url) {\n            c = c.substr(0, 62) + '-_';\n        }\n        for (i = 0; out.length * 6 < bl;) {\n            out += c.charAt((ta ^ arr[i] >>> bits) >>> 26);\n            if (bits < 6) {\n                ta = arr[i] << (6 - bits);\n                bits += 26;\n                i++;\n            }\n            else {\n                ta <<= 6;\n                bits -= 6;\n            }\n        }\n        while ((out.length & 3) && !_noEquals) {\n            out += \"=\";\n        }\n        return out;\n    },\n    /** Convert from a base64 string to a bitArray */\n    toBits: function (str, _url) {\n        str = str.replace(/\\s|=/g, '');\n        var out = [], i, bits = 0, c = sjcl.codec.base64._chars, ta = 0, x;\n        if (_url) {\n            c = c.substr(0, 62) + '-_';\n        }\n        for (i = 0; i < str.length; i++) {\n            x = c.indexOf(str.charAt(i));\n            if (x < 0) {\n                throw new sjcl.exception.invalid(\"this isn't base64!\");\n            }\n            if (bits > 26) {\n                bits -= 26;\n                out.push(ta ^ x >>> bits);\n                ta = x << (32 - bits);\n            }\n            else {\n                bits += 6;\n                ta ^= x << (32 - bits);\n            }\n        }\n        if (bits & 56) {\n            out.push(sjcl.bitArray.partial(bits & 56, ta, 1));\n        }\n        return out;\n    }\n};\nsjcl.codec.base64url = {\n    fromBits: function (arr) { return sjcl.codec.base64.fromBits(arr, 1, 1); },\n    toBits: function (str) { return sjcl.codec.base64.toBits(str, 1); }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Arrays of bytes\n * @namespace\n */\nsjcl.codec.bytes = {\n    /** Convert from a bitArray to an array of bytes. */\n    fromBits: function (arr) {\n        var out = [], bl = sjcl.bitArray.bitLength(arr), i, tmp;\n        for (i = 0; i < bl / 8; i++) {\n            if ((i & 3) === 0) {\n                tmp = arr[i / 4];\n            }\n            out.push(tmp >>> 24);\n            tmp <<= 8;\n        }\n        return out;\n    },\n    /** Convert from an array of bytes to a bitArray. */\n    toBits: function (bytes) {\n        var out = [], i, tmp = 0;\n        for (i = 0; i < bytes.length; i++) {\n            tmp = tmp << 8 | bytes[i];\n            if ((i & 3) === 3) {\n                out.push(tmp);\n                tmp = 0;\n            }\n        }\n        if (i & 3) {\n            out.push(sjcl.bitArray.partial(8 * (i & 3), tmp));\n        }\n        return out;\n    }\n};\n/** @fileOverview Javascript SHA-256 implementation.\n *\n * An older version of this implementation is available in the public\n * domain, but this one is (c) Emily Stark, Mike Hamburg, Dan Boneh,\n * Stanford University 2008-2010 and BSD-licensed for liability\n * reasons.\n *\n * Special thanks to Aldo Cortesi for pointing out several bugs in\n * this code.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * Context for a SHA-256 operation in progress.\n * @constructor\n */\nsjcl.hash.sha256 = function (hash) {\n    if (!this._key[0]) {\n        this._precompute();\n    }\n    if (hash) {\n        this._h = hash._h.slice(0);\n        this._buffer = hash._buffer.slice(0);\n        this._length = hash._length;\n    }\n    else {\n        this.reset();\n    }\n};\n/**\n * Hash a string or an array of words.\n * @static\n * @param {bitArray|String} data the data to hash.\n * @return {bitArray} The hash value, an array of 16 big-endian words.\n */\nsjcl.hash.sha256.hash = function (data) {\n    return (new sjcl.hash.sha256()).update(data).finalize();\n};\nsjcl.hash.sha256.prototype = {\n    /**\n     * The hash's block size, in bits.\n     * @constant\n     */\n    blockSize: 512,\n    /**\n     * Reset the hash state.\n     * @return this\n     */\n    reset: function () {\n        this._h = this._init.slice(0);\n        this._buffer = [];\n        this._length = 0;\n        return this;\n    },\n    /**\n     * Input several words to the hash.\n     * @param {bitArray|String} data the data to hash.\n     * @return this\n     */\n    update: function (data) {\n        if (typeof data === \"string\") {\n            data = sjcl.codec.utf8String.toBits(data);\n        }\n        var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data), ol = this._length, nl = this._length = ol + sjcl.bitArray.bitLength(data);\n        if (nl > 9007199254740991) {\n            throw new sjcl.exception.invalid(\"Cannot hash more than 2^53 - 1 bits\");\n        }\n        if (typeof Uint32Array !== 'undefined') {\n            var c = new Uint32Array(b);\n            var j = 0;\n            for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {\n                this._block(c.subarray(16 * j, 16 * (j + 1)));\n                j += 1;\n            }\n            b.splice(0, 16 * j);\n        }\n        else {\n            for (i = 512 + ol - ((512 + ol) & 511); i <= nl; i += 512) {\n                this._block(b.splice(0, 16));\n            }\n        }\n        return this;\n    },\n    /**\n     * Complete hashing and output the hash value.\n     * @return {bitArray} The hash value, an array of 8 big-endian words.\n     */\n    finalize: function () {\n        var i, b = this._buffer, h = this._h;\n        // Round out and push the buffer\n        b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1, 1)]);\n        // Round out the buffer to a multiple of 16 words, less the 2 length words.\n        for (i = b.length + 2; i & 15; i++) {\n            b.push(0);\n        }\n        // append the length\n        b.push(Math.floor(this._length / 0x100000000));\n        b.push(this._length | 0);\n        while (b.length) {\n            this._block(b.splice(0, 16));\n        }\n        this.reset();\n        return h;\n    },\n    /**\n     * The SHA-256 initialization vector, to be precomputed.\n     * @private\n     */\n    _init: [],\n    /*\n    _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],\n    */\n    /**\n     * The SHA-256 hash key, to be precomputed.\n     * @private\n     */\n    _key: [],\n    /*\n    _key:\n      [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n       0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n       0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n       0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n       0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n       0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n       0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n       0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],\n    */\n    /**\n     * Function to precompute _init and _key.\n     * @private\n     */\n    _precompute: function () {\n        var i = 0, prime = 2, factor, isPrime;\n        function frac(x) { return (x - Math.floor(x)) * 0x100000000 | 0; }\n        for (; i < 64; prime++) {\n            isPrime = true;\n            for (factor = 2; factor * factor <= prime; factor++) {\n                if (prime % factor === 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                if (i < 8) {\n                    this._init[i] = frac(Math.pow(prime, 1 / 2));\n                }\n                this._key[i] = frac(Math.pow(prime, 1 / 3));\n                i++;\n            }\n        }\n    },\n    /**\n     * Perform one cycle of SHA-256.\n     * @param {Uint32Array|bitArray} w one block of words.\n     * @private\n     */\n    _block: function (w) {\n        var i, tmp, a, b, h = this._h, k = this._key, h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3], h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];\n        /* Rationale for placement of |0 :\n         * If a value can overflow is original 32 bits by a factor of more than a few\n         * million (2^23 ish), there is a possibility that it might overflow the\n         * 53-bit mantissa and lose precision.\n         *\n         * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that\n         * propagates around the loop, and on the hash state h[].  I don't believe\n         * that the clamps on h4 and on h0 are strictly necessary, but it's close\n         * (for h4 anyway), and better safe than sorry.\n         *\n         * The clamps on h[] are necessary for the output to be correct even in the\n         * common case and for short inputs.\n         */\n        for (i = 0; i < 64; i++) {\n            // load up the input word for this round\n            if (i < 16) {\n                tmp = w[i];\n            }\n            else {\n                a = w[(i + 1) & 15];\n                b = w[(i + 14) & 15];\n                tmp = w[i & 15] = ((a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) +\n                    (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) +\n                    w[i & 15] + w[(i + 9) & 15]) | 0;\n            }\n            tmp = (tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + k[i]); // | 0;\n            // shift register\n            h7 = h6;\n            h6 = h5;\n            h5 = h4;\n            h4 = h3 + tmp | 0;\n            h3 = h2;\n            h2 = h1;\n            h1 = h0;\n            h0 = (tmp + ((h1 & h2) ^ (h3 & (h1 ^ h2))) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10)) | 0;\n        }\n        h[0] = h[0] + h0 | 0;\n        h[1] = h[1] + h1 | 0;\n        h[2] = h[2] + h2 | 0;\n        h[3] = h[3] + h3 | 0;\n        h[4] = h[4] + h4 | 0;\n        h[5] = h[5] + h5 | 0;\n        h[6] = h[6] + h6 | 0;\n        h[7] = h[7] + h7 | 0;\n    }\n};\n/** @fileOverview CCM mode implementation.\n *\n * Special thanks to Roy Nicholson for pointing out a bug in our\n * implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * CTR mode with CBC MAC.\n * @namespace\n */\nsjcl.mode.ccm = {\n    /** The name of the mode.\n     * @constant\n     */\n    name: \"ccm\",\n    _progressListeners: [],\n    listenProgress: function (cb) {\n        sjcl.mode.ccm._progressListeners.push(cb);\n    },\n    unListenProgress: function (cb) {\n        var index = sjcl.mode.ccm._progressListeners.indexOf(cb);\n        if (index > -1) {\n            sjcl.mode.ccm._progressListeners.splice(index, 1);\n        }\n    },\n    _callProgressListener: function (val) {\n        var p = sjcl.mode.ccm._progressListeners.slice(), i;\n        for (i = 0; i < p.length; i += 1) {\n            p[i](val);\n        }\n    },\n    /** Encrypt in CCM mode.\n     * @static\n     * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n     * @param {bitArray} plaintext The plaintext data.\n     * @param {bitArray} iv The initialization value.\n     * @param {bitArray} [adata=[]] The authenticated data.\n     * @param {Number} [tlen=64] the desired tag length, in bits.\n     * @return {bitArray} The encrypted data, an array of bytes.\n     */\n    encrypt: function (prf, plaintext, iv, adata, tlen) {\n        var L, out = plaintext.slice(0), tag, w = sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;\n        tlen = tlen || 64;\n        adata = adata || [];\n        if (ivl < 7) {\n            throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n        }\n        // compute the length of the length\n        for (L = 2; L < 4 && ol >>> 8 * L; L++) { }\n        if (L < 15 - ivl) {\n            L = 15 - ivl;\n        }\n        iv = w.clamp(iv, 8 * (15 - L));\n        // compute the tag\n        tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);\n        // encrypt\n        out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n        return w.concat(out.data, out.tag);\n    },\n    /** Decrypt in CCM mode.\n     * @static\n     * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.\n     * @param {bitArray} ciphertext The ciphertext data.\n     * @param {bitArray} iv The initialization value.\n     * @param {bitArray} [adata=[]] adata The authenticated data.\n     * @param {Number} [tlen=64] tlen the desired tag length, in bits.\n     * @return {bitArray} The decrypted data.\n     */\n    decrypt: function (prf, ciphertext, iv, adata, tlen) {\n        tlen = tlen || 64;\n        adata = adata || [];\n        var L, w = sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(ciphertext), out = w.clamp(ciphertext, ol - tlen), tag = w.bitSlice(ciphertext, ol - tlen), tag2;\n        ol = (ol - tlen) / 8;\n        if (ivl < 7) {\n            throw new sjcl.exception.invalid(\"ccm: iv must be at least 7 bytes\");\n        }\n        // compute the length of the length\n        for (L = 2; L < 4 && ol >>> 8 * L; L++) { }\n        if (L < 15 - ivl) {\n            L = 15 - ivl;\n        }\n        iv = w.clamp(iv, 8 * (15 - L));\n        // decrypt\n        out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);\n        // check the tag\n        tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);\n        if (!w.equal(out.tag, tag2)) {\n            throw new sjcl.exception.corrupt(\"ccm: tag doesn't match\");\n        }\n        return out.data;\n    },\n    _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {\n        var mac, tmp, i, macData = [], w = sjcl.bitArray, xor = w._xor4;\n        // mac the flags\n        mac = [w.partial(8, (adata.length ? 1 << 6 : 0) | (tlen - 2) << 2 | L - 1)];\n        // mac the iv and length\n        mac = w.concat(mac, iv);\n        mac[3] |= ol;\n        mac = prf.encrypt(mac);\n        if (adata.length) {\n            // mac the associated data.  start with its length...\n            tmp = w.bitLength(adata) / 8;\n            if (tmp <= 0xFEFF) {\n                macData = [w.partial(16, tmp)];\n            }\n            else if (tmp <= 0xFFFFFFFF) {\n                macData = w.concat([w.partial(16, 0xFFFE)], [tmp]);\n            } // else ...\n            // mac the data itself\n            macData = w.concat(macData, adata);\n            for (i = 0; i < macData.length; i += 4) {\n                mac = prf.encrypt(xor(mac, macData.slice(i, i + 4).concat([0, 0, 0])));\n            }\n        }\n        return mac;\n    },\n    /* Compute the (unencrypted) authentication tag, according to the CCM specification\n     * @param {Object} prf The pseudorandom function.\n     * @param {bitArray} plaintext The plaintext data.\n     * @param {bitArray} iv The initialization value.\n     * @param {bitArray} adata The authenticated data.\n     * @param {Number} tlen the desired tag length, in bits.\n     * @return {bitArray} The tag, but not yet encrypted.\n     * @private\n     */\n    _computeTag: function (prf, plaintext, iv, adata, tlen, L) {\n        // compute B[0]\n        var mac, i, w = sjcl.bitArray, xor = w._xor4;\n        tlen /= 8;\n        // check tag length and message length\n        if (tlen % 2 || tlen < 4 || tlen > 16) {\n            throw new sjcl.exception.invalid(\"ccm: invalid tag length\");\n        }\n        if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {\n            // I don't want to deal with extracting high words from doubles.\n            throw new sjcl.exception.bug(\"ccm: can't deal with 4GiB or more data\");\n        }\n        mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext) / 8, L);\n        // mac the plaintext\n        for (i = 0; i < plaintext.length; i += 4) {\n            mac = prf.encrypt(xor(mac, plaintext.slice(i, i + 4).concat([0, 0, 0])));\n        }\n        return w.clamp(mac, tlen * 8);\n    },\n    /** CCM CTR mode.\n     * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.\n     * May mutate its arguments.\n     * @param {Object} prf The PRF.\n     * @param {bitArray} data The data to be encrypted or decrypted.\n     * @param {bitArray} iv The initialization vector.\n     * @param {bitArray} tag The authentication tag.\n     * @param {Number} tlen The length of th etag, in bits.\n     * @param {Number} L The CCM L value.\n     * @return {Object} An object with data and tag, the en/decryption of data and tag values.\n     * @private\n     */\n    _ctrMode: function (prf, data, iv, tag, tlen, L) {\n        var enc, i, w = sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl = w.bitLength(data), n = l / 50, p = n;\n        // start the ctr\n        ctr = w.concat([w.partial(8, L - 1)], iv).concat([0, 0, 0]).slice(0, 4);\n        // en/decrypt the tag\n        tag = w.bitSlice(xor(tag, prf.encrypt(ctr)), 0, tlen);\n        // en/decrypt the data\n        if (!l) {\n            return { tag: tag, data: [] };\n        }\n        for (i = 0; i < l; i += 4) {\n            if (i > n) {\n                sjcl.mode.ccm._callProgressListener(i / l);\n                n += p;\n            }\n            ctr[3]++;\n            enc = prf.encrypt(ctr);\n            data[i] ^= enc[0];\n            data[i + 1] ^= enc[1];\n            data[i + 2] ^= enc[2];\n            data[i + 3] ^= enc[3];\n        }\n        return { tag: tag, data: w.clamp(data, bl) };\n    }\n};\n/** @fileOverview HMAC implementation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/** HMAC with the specified hash function.\n * @constructor\n * @param {bitArray} key the key for HMAC.\n * @param {Object} [Hash=sjcl.hash.sha256] The hash function to use.\n */\nsjcl.misc.hmac = function (key, Hash) {\n    this._hash = Hash = Hash || sjcl.hash.sha256;\n    var exKey = [[], []], i, bs = Hash.prototype.blockSize / 32;\n    this._baseHash = [new Hash(), new Hash()];\n    if (key.length > bs) {\n        key = Hash.hash(key);\n    }\n    for (i = 0; i < bs; i++) {\n        exKey[0][i] = key[i] ^ 0x36363636;\n        exKey[1][i] = key[i] ^ 0x5C5C5C5C;\n    }\n    this._baseHash[0].update(exKey[0]);\n    this._baseHash[1].update(exKey[1]);\n    this._resultHash = new Hash(this._baseHash[0]);\n};\n/** HMAC with the specified hash function.  Also called encrypt since it's a prf.\n * @param {bitArray|String} data The data to mac.\n */\nsjcl.misc.hmac.prototype.encrypt = sjcl.misc.hmac.prototype.mac = function (data) {\n    if (!this._updated) {\n        this.update(data);\n        return this.digest(data);\n    }\n    else {\n        throw new sjcl.exception.invalid(\"encrypt on already updated hmac called!\");\n    }\n};\nsjcl.misc.hmac.prototype.reset = function () {\n    this._resultHash = new this._hash(this._baseHash[0]);\n    this._updated = false;\n};\nsjcl.misc.hmac.prototype.update = function (data) {\n    this._updated = true;\n    this._resultHash.update(data);\n};\nsjcl.misc.hmac.prototype.digest = function () {\n    var w = this._resultHash.finalize(), result = new (this._hash)(this._baseHash[1]).update(w).finalize();\n    this.reset();\n    return result;\n};\n/** @fileOverview Password-based key-derivation function, version 2.0.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/** Password-Based Key-Derivation Function, version 2.0.\n *\n * Generate keys from passwords using PBKDF2-HMAC-SHA256.\n *\n * This is the method specified by RSA's PKCS #5 standard.\n *\n * @param {bitArray|String} password  The password.\n * @param {bitArray|String} salt The salt.  Should have lots of entropy.\n * @param {Number} [count=1000] The number of iterations.  Higher numbers make the function slower but more secure.\n * @param {Number} [length] The length of the derived key.  Defaults to the\n                            output size of the hash function.\n * @param {Object} [Prff=sjcl.misc.hmac] The pseudorandom function family.\n * @return {bitArray} the derived key.\n */\nsjcl.misc.pbkdf2 = function (password, salt, count, length, Prff) {\n    count = count || 10000;\n    if (length < 0 || count < 0) {\n        throw new sjcl.exception.invalid(\"invalid params to pbkdf2\");\n    }\n    if (typeof password === \"string\") {\n        password = sjcl.codec.utf8String.toBits(password);\n    }\n    if (typeof salt === \"string\") {\n        salt = sjcl.codec.utf8String.toBits(salt);\n    }\n    Prff = Prff || sjcl.misc.hmac;\n    var prf = new Prff(password), u, ui, i, j, k, out = [], b = sjcl.bitArray;\n    for (k = 1; 32 * out.length < (length || 1); k++) {\n        u = ui = prf.encrypt(b.concat(salt, [k]));\n        for (i = 1; i < count; i++) {\n            ui = prf.encrypt(ui);\n            for (j = 0; j < ui.length; j++) {\n                u[j] ^= ui[j];\n            }\n        }\n        out = out.concat(u);\n    }\n    if (length) {\n        out = b.clamp(out, length);\n    }\n    return out;\n};\n/** @fileOverview Random number generator.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n * @author Michael Brooks\n * @author Steve Thomas\n */\n/**\n * @class Random number generator\n * @description\n * <b>Use sjcl.random as a singleton for this class!</b>\n * <p>\n * This random number generator is a derivative of Ferguson and Schneier's\n * generator Fortuna.  It collects entropy from various events into several\n * pools, implemented by streaming SHA-256 instances.  It differs from\n * ordinary Fortuna in a few ways, though.\n * </p>\n *\n * <p>\n * Most importantly, it has an entropy estimator.  This is present because\n * there is a strong conflict here between making the generator available\n * as soon as possible, and making sure that it doesn't \"run on empty\".\n * In Fortuna, there is a saved state file, and the system is likely to have\n * time to warm up.\n * </p>\n *\n * <p>\n * Second, because users are unlikely to stay on the page for very long,\n * and to speed startup time, the number of pools increases logarithmically:\n * a new pool is created when the previous one is actually used for a reseed.\n * This gives the same asymptotic guarantees as Fortuna, but gives more\n * entropy to early reseeds.\n * </p>\n *\n * <p>\n * The entire mechanism here feels pretty klunky.  Furthermore, there are\n * several improvements that should be made, including support for\n * dedicated cryptographic functions that may be present in some browsers;\n * state files in local storage; cookies containing randomness; etc.  So\n * look for improvements in future versions.\n * </p>\n * @constructor\n */\nsjcl.prng = function (defaultParanoia) {\n    /* private */\n    this._pools = [new sjcl.hash.sha256()];\n    this._poolEntropy = [0];\n    this._reseedCount = 0;\n    this._robins = {};\n    this._eventId = 0;\n    this._collectorIds = {};\n    this._collectorIdNext = 0;\n    this._strength = 0;\n    this._poolStrength = 0;\n    this._nextReseed = 0;\n    this._key = [0, 0, 0, 0, 0, 0, 0, 0];\n    this._counter = [0, 0, 0, 0];\n    this._cipher = undefined;\n    this._defaultParanoia = defaultParanoia;\n    /* event listener stuff */\n    this._collectorsStarted = false;\n    this._callbacks = { progress: {}, seeded: {} };\n    this._callbackI = 0;\n    /* constants */\n    this._NOT_READY = 0;\n    this._READY = 1;\n    this._REQUIRES_RESEED = 2;\n    this._MAX_WORDS_PER_BURST = 65536;\n    this._PARANOIA_LEVELS = [0, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024];\n    this._MILLISECONDS_PER_RESEED = 30000;\n    this._BITS_PER_RESEED = 80;\n};\nsjcl.prng.prototype = {\n    /** Generate several random words, and return them in an array.\n     * A word consists of 32 bits (4 bytes)\n     * @param {Number} nwords The number of words to generate.\n     */\n    randomWords: function (nwords, paranoia) {\n        var out = [], i, readiness = this.isReady(paranoia), g;\n        if (readiness === this._NOT_READY) {\n            throw new sjcl.exception.notReady(\"generator isn't seeded\");\n        }\n        else if (readiness & this._REQUIRES_RESEED) {\n            this._reseedFromPools(!(readiness & this._READY));\n        }\n        for (i = 0; i < nwords; i += 4) {\n            if ((i + 1) % this._MAX_WORDS_PER_BURST === 0) {\n                this._gate();\n            }\n            g = this._gen4words();\n            out.push(g[0], g[1], g[2], g[3]);\n        }\n        this._gate();\n        return out.slice(0, nwords);\n    },\n    setDefaultParanoia: function (paranoia, allowZeroParanoia) {\n        if (paranoia === 0 && allowZeroParanoia !== \"Setting paranoia=0 will ruin your security; use it only for testing\") {\n            throw new sjcl.exception.invalid(\"Setting paranoia=0 will ruin your security; use it only for testing\");\n        }\n        this._defaultParanoia = paranoia;\n    },\n    /**\n     * Add entropy to the pools.\n     * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string\n     * @param {Number} estimatedEntropy The estimated entropy of data, in bits\n     * @param {String} source The source of the entropy, eg \"mouse\"\n     */\n    addEntropy: function (data, estimatedEntropy, source) {\n        source = source || \"user\";\n        var id, i, tmp, t = (new Date()).valueOf(), robin = this._robins[source], oldReady = this.isReady(), err = 0, objName;\n        id = this._collectorIds[source];\n        if (id === undefined) {\n            id = this._collectorIds[source] = this._collectorIdNext++;\n        }\n        if (robin === undefined) {\n            robin = this._robins[source] = 0;\n        }\n        this._robins[source] = (this._robins[source] + 1) % this._pools.length;\n        switch (typeof (data)) {\n            case \"number\":\n                if (estimatedEntropy === undefined) {\n                    estimatedEntropy = 1;\n                }\n                this._pools[robin].update([id, this._eventId++, 1, estimatedEntropy, t, 1, data | 0]);\n                break;\n            case \"object\":\n                objName = Object.prototype.toString.call(data);\n                if (objName === \"[object Uint32Array]\") {\n                    tmp = [];\n                    for (i = 0; i < data.length; i++) {\n                        tmp.push(data[i]);\n                    }\n                    data = tmp;\n                }\n                else {\n                    if (objName !== \"[object Array]\") {\n                        err = 1;\n                    }\n                    for (i = 0; i < data.length && !err; i++) {\n                        if (typeof (data[i]) !== \"number\") {\n                            err = 1;\n                        }\n                    }\n                }\n                if (!err) {\n                    if (estimatedEntropy === undefined) {\n                        /* horrible entropy estimator */\n                        estimatedEntropy = 0;\n                        for (i = 0; i < data.length; i++) {\n                            tmp = data[i];\n                            while (tmp > 0) {\n                                estimatedEntropy++;\n                                tmp = tmp >>> 1;\n                            }\n                        }\n                    }\n                    this._pools[robin].update([id, this._eventId++, 2, estimatedEntropy, t, data.length].concat(data));\n                }\n                break;\n            case \"string\":\n                if (estimatedEntropy === undefined) {\n                    /* English text has just over 1 bit per character of entropy.\n                     * But this might be HTML or something, and have far less\n                     * entropy than English...  Oh well, let's just say one bit.\n                     */\n                    estimatedEntropy = data.length;\n                }\n                this._pools[robin].update([id, this._eventId++, 3, estimatedEntropy, t, data.length]);\n                this._pools[robin].update(data);\n                break;\n            default:\n                err = 1;\n        }\n        if (err) {\n            throw new sjcl.exception.bug(\"random: addEntropy only supports number, array of numbers or string\");\n        }\n        /* record the new strength */\n        this._poolEntropy[robin] += estimatedEntropy;\n        this._poolStrength += estimatedEntropy;\n        /* fire off events */\n        if (oldReady === this._NOT_READY) {\n            if (this.isReady() !== this._NOT_READY) {\n                this._fireEvent(\"seeded\", Math.max(this._strength, this._poolStrength));\n            }\n            this._fireEvent(\"progress\", this.getProgress());\n        }\n    },\n    /** Is the generator ready? */\n    isReady: function (paranoia) {\n        var entropyRequired = this._PARANOIA_LEVELS[(paranoia !== undefined) ? paranoia : this._defaultParanoia];\n        if (this._strength && this._strength >= entropyRequired) {\n            return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?\n                this._REQUIRES_RESEED | this._READY :\n                this._READY;\n        }\n        else {\n            return (this._poolStrength >= entropyRequired) ?\n                this._REQUIRES_RESEED | this._NOT_READY :\n                this._NOT_READY;\n        }\n    },\n    /** Get the generator's progress toward readiness, as a fraction */\n    getProgress: function (paranoia) {\n        var entropyRequired = this._PARANOIA_LEVELS[paranoia ? paranoia : this._defaultParanoia];\n        if (this._strength >= entropyRequired) {\n            return 1.0;\n        }\n        else {\n            return (this._poolStrength > entropyRequired) ?\n                1.0 :\n                this._poolStrength / entropyRequired;\n        }\n    },\n    /** start the built-in entropy collectors */\n    startCollectors: function () {\n        if (this._collectorsStarted) {\n            return;\n        }\n        this._eventListener = {\n            loadTimeCollector: this._bind(this._loadTimeCollector),\n            mouseCollector: this._bind(this._mouseCollector),\n            keyboardCollector: this._bind(this._keyboardCollector),\n            accelerometerCollector: this._bind(this._accelerometerCollector),\n            touchCollector: this._bind(this._touchCollector)\n        };\n        if (window.addEventListener) {\n            window.addEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n            window.addEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n            window.addEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n            window.addEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n            window.addEventListener(\"touchmove\", this._eventListener.touchCollector, false);\n        }\n        else if (document.attachEvent) {\n            document.attachEvent(\"onload\", this._eventListener.loadTimeCollector);\n            document.attachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n            document.attachEvent(\"keypress\", this._eventListener.keyboardCollector);\n        }\n        else {\n            throw new sjcl.exception.bug(\"can't attach event\");\n        }\n        this._collectorsStarted = true;\n    },\n    /** stop the built-in entropy collectors */\n    stopCollectors: function () {\n        if (!this._collectorsStarted) {\n            return;\n        }\n        if (window.removeEventListener) {\n            window.removeEventListener(\"load\", this._eventListener.loadTimeCollector, false);\n            window.removeEventListener(\"mousemove\", this._eventListener.mouseCollector, false);\n            window.removeEventListener(\"keypress\", this._eventListener.keyboardCollector, false);\n            window.removeEventListener(\"devicemotion\", this._eventListener.accelerometerCollector, false);\n            window.removeEventListener(\"touchmove\", this._eventListener.touchCollector, false);\n        }\n        else if (document.detachEvent) {\n            document.detachEvent(\"onload\", this._eventListener.loadTimeCollector);\n            document.detachEvent(\"onmousemove\", this._eventListener.mouseCollector);\n            document.detachEvent(\"keypress\", this._eventListener.keyboardCollector);\n        }\n        this._collectorsStarted = false;\n    },\n    /* use a cookie to store entropy.\n    useCookie: function (all_cookies) {\n        throw new sjcl.exception.bug(\"random: useCookie is unimplemented\");\n    },*/\n    /** add an event listener for progress or seeded-ness. */\n    addEventListener: function (name, callback) {\n        this._callbacks[name][this._callbackI++] = callback;\n    },\n    /** remove an event listener for progress or seeded-ness */\n    removeEventListener: function (name, cb) {\n        var i, j, cbs = this._callbacks[name], jsTemp = [];\n        /* I'm not sure if this is necessary; in C++, iterating over a\n         * collection and modifying it at the same time is a no-no.\n         */\n        for (j in cbs) {\n            if (cbs.hasOwnProperty(j) && cbs[j] === cb) {\n                jsTemp.push(j);\n            }\n        }\n        for (i = 0; i < jsTemp.length; i++) {\n            j = jsTemp[i];\n            delete cbs[j];\n        }\n    },\n    _bind: function (func) {\n        var that = this;\n        return function () {\n            func.apply(that, arguments);\n        };\n    },\n    /** Generate 4 random words, no reseed, no gate.\n     * @private\n     */\n    _gen4words: function () {\n        for (var i = 0; i < 4; i++) {\n            this._counter[i] = this._counter[i] + 1 | 0;\n            if (this._counter[i]) {\n                break;\n            }\n        }\n        return this._cipher.encrypt(this._counter);\n    },\n    /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.\n     * @private\n     */\n    _gate: function () {\n        this._key = this._gen4words().concat(this._gen4words());\n        this._cipher = new sjcl.cipher.aes(this._key);\n    },\n    /** Reseed the generator with the given words\n     * @private\n     */\n    _reseed: function (seedWords) {\n        this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));\n        this._cipher = new sjcl.cipher.aes(this._key);\n        for (var i = 0; i < 4; i++) {\n            this._counter[i] = this._counter[i] + 1 | 0;\n            if (this._counter[i]) {\n                break;\n            }\n        }\n    },\n    /** reseed the data from the entropy pools\n     * @param full If set, use all the entropy pools in the reseed.\n     */\n    _reseedFromPools: function (full) {\n        var reseedData = [], strength = 0, i;\n        this._nextReseed = reseedData[0] =\n            (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;\n        for (i = 0; i < 16; i++) {\n            /* On some browsers, this is cryptographically random.  So we might\n             * as well toss it in the pot and stir...\n             */\n            reseedData.push(Math.random() * 0x100000000 | 0);\n        }\n        for (i = 0; i < this._pools.length; i++) {\n            reseedData = reseedData.concat(this._pools[i].finalize());\n            strength += this._poolEntropy[i];\n            this._poolEntropy[i] = 0;\n            if (!full && (this._reseedCount & (1 << i))) {\n                break;\n            }\n        }\n        /* if we used the last pool, push a new one onto the stack */\n        if (this._reseedCount >= 1 << this._pools.length) {\n            this._pools.push(new sjcl.hash.sha256());\n            this._poolEntropy.push(0);\n        }\n        /* how strong was this reseed? */\n        this._poolStrength -= strength;\n        if (strength > this._strength) {\n            this._strength = strength;\n        }\n        this._reseedCount++;\n        this._reseed(reseedData);\n    },\n    _keyboardCollector: function () {\n        this._addCurrentTimeToEntropy(1);\n    },\n    _mouseCollector: function (ev) {\n        var x, y;\n        try {\n            x = ev.x || ev.clientX || ev.offsetX || 0;\n            y = ev.y || ev.clientY || ev.offsetY || 0;\n        }\n        catch (err) {\n            // Event originated from a secure element. No mouse position available.\n            x = 0;\n            y = 0;\n        }\n        if (x != 0 && y != 0) {\n            this.addEntropy([x, y], 2, \"mouse\");\n        }\n        this._addCurrentTimeToEntropy(0);\n    },\n    _touchCollector: function (ev) {\n        var touch = ev.touches[0] || ev.changedTouches[0];\n        var x = touch.pageX || touch.clientX, y = touch.pageY || touch.clientY;\n        this.addEntropy([x, y], 1, \"touch\");\n        this._addCurrentTimeToEntropy(0);\n    },\n    _loadTimeCollector: function () {\n        this._addCurrentTimeToEntropy(2);\n    },\n    _addCurrentTimeToEntropy: function (estimatedEntropy) {\n        if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === \"function\") {\n            //how much entropy do we want to add here?\n            this.addEntropy(window.performance.now(), estimatedEntropy, \"loadtime\");\n        }\n        else {\n            this.addEntropy((new Date()).valueOf(), estimatedEntropy, \"loadtime\");\n        }\n    },\n    _accelerometerCollector: function (ev) {\n        var ac = ev.accelerationIncludingGravity.x || ev.accelerationIncludingGravity.y || ev.accelerationIncludingGravity.z;\n        if (window.orientation) {\n            var or = window.orientation;\n            if (typeof or === \"number\") {\n                this.addEntropy(or, 1, \"accelerometer\");\n            }\n        }\n        if (ac) {\n            this.addEntropy(ac, 2, \"accelerometer\");\n        }\n        this._addCurrentTimeToEntropy(0);\n    },\n    _fireEvent: function (name, arg) {\n        var j, cbs = sjcl.random._callbacks[name], cbsTemp = [];\n        /* TODO: there is a race condition between removing collectors and firing them */\n        /* I'm not sure if this is necessary; in C++, iterating over a\n         * collection and modifying it at the same time is a no-no.\n         */\n        for (j in cbs) {\n            if (cbs.hasOwnProperty(j)) {\n                cbsTemp.push(cbs[j]);\n            }\n        }\n        for (j = 0; j < cbsTemp.length; j++) {\n            cbsTemp[j](arg);\n        }\n    }\n};\n/** an instance for the prng.\n* @see sjcl.prng\n*/\nsjcl.random = new sjcl.prng(6);\n(function () {\n    // function for getting nodejs crypto module. catches and ignores errors.\n    function getCryptoModule() {\n        try {\n            return require('crypto');\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    try {\n        var buf, crypt, ab;\n        // get cryptographically strong entropy depending on runtime environment\n        if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {\n            buf = crypt.randomBytes(1024 / 8);\n            buf = new Uint32Array(new Uint8Array(buf).buffer);\n            sjcl.random.addEntropy(buf, 1024, \"crypto.randomBytes\");\n        }\n        else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {\n            ab = new Uint32Array(32);\n            if (window.crypto && window.crypto.getRandomValues) {\n                window.crypto.getRandomValues(ab);\n            }\n            else if (window.msCrypto && window.msCrypto.getRandomValues) {\n                window.msCrypto.getRandomValues(ab);\n            }\n            else {\n                return;\n            }\n            // get cryptographically strong entropy in Webkit\n            sjcl.random.addEntropy(ab, 1024, \"crypto.getRandomValues\");\n        }\n        else {\n            // no getRandomValues :-(\n        }\n    }\n    catch (e) {\n        if (typeof window !== 'undefined' && window.console) {\n            console.log(\"There was an error collecting entropy from the browser:\");\n            console.log(e);\n            //we do not want the library to fail due to randomness not being maintained.\n        }\n    }\n}());\n/** @fileOverview Convenience functions centered around JSON encapsulation.\n *\n * @author Emily Stark\n * @author Mike Hamburg\n * @author Dan Boneh\n */\n/**\n * JSON encapsulation\n * @namespace\n */\nsjcl.json = {\n    /** Default values for encryption */\n    defaults: { v: 1, iter: 10000, ks: 128, ts: 64, mode: \"ccm\", adata: \"\", cipher: \"aes\" },\n    /** Simple encryption function.\n     * @param {String|bitArray} password The password or key.\n     * @param {String} plaintext The data to encrypt.\n     * @param {Object} [params] The parameters including tag, iv and salt.\n     * @param {Object} [rp] A returned version with filled-in parameters.\n     * @return {Object} The cipher raw data.\n     * @throws {sjcl.exception.invalid} if a parameter is invalid.\n     */\n    _encrypt: function (password, plaintext, params, rp) {\n        params = params || {};\n        rp = rp || {};\n        var j = sjcl.json, p = j._add({ iv: sjcl.random.randomWords(4, 0) }, j.defaults), tmp, prp, adata;\n        j._add(p, params);\n        adata = p.adata;\n        if (typeof p.salt === \"string\") {\n            p.salt = sjcl.codec.base64.toBits(p.salt);\n        }\n        if (typeof p.iv === \"string\") {\n            p.iv = sjcl.codec.base64.toBits(p.iv);\n        }\n        if (!sjcl.mode[p.mode] ||\n            !sjcl.cipher[p.cipher] ||\n            (typeof password === \"string\" && p.iter <= 100) ||\n            (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n            (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n            (p.iv.length < 2 || p.iv.length > 4)) {\n            throw new sjcl.exception.invalid(\"json encrypt: invalid parameters\");\n        }\n        if (typeof password === \"string\") {\n            tmp = sjcl.misc.cachedPbkdf2(password, p);\n            password = tmp.key.slice(0, p.ks / 32);\n            p.salt = tmp.salt;\n        }\n        else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.publicKey) {\n            tmp = password.kem();\n            p.kemtag = tmp.tag;\n            password = tmp.key.slice(0, p.ks / 32);\n        }\n        if (typeof plaintext === \"string\") {\n            plaintext = sjcl.codec.utf8String.toBits(plaintext);\n        }\n        if (typeof adata === \"string\") {\n            p.adata = adata = sjcl.codec.utf8String.toBits(adata);\n        }\n        prp = new sjcl.cipher[p.cipher](password);\n        /* return the json data */\n        j._add(rp, p);\n        rp.key = password;\n        /* do the encryption */\n        if (p.mode === \"ccm\" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && plaintext instanceof ArrayBuffer) {\n            p.ct = sjcl.arrayBuffer.ccm.encrypt(prp, plaintext, p.iv, adata, p.ts);\n        }\n        else {\n            p.ct = sjcl.mode[p.mode].encrypt(prp, plaintext, p.iv, adata, p.ts);\n        }\n        //return j.encode(j._subtract(p, j.defaults));\n        return p;\n    },\n    /** Simple encryption function.\n     * @param {String|bitArray} password The password or key.\n     * @param {String} plaintext The data to encrypt.\n     * @param {Object} [params] The parameters including tag, iv and salt.\n     * @param {Object} [rp] A returned version with filled-in parameters.\n     * @return {String} The ciphertext serialized data.\n     * @throws {sjcl.exception.invalid} if a parameter is invalid.\n     */\n    encrypt: function (password, plaintext, params, rp) {\n        var j = sjcl.json, p = j._encrypt.apply(j, arguments);\n        return j.encode(p);\n    },\n    /** Simple decryption function.\n     * @param {String|bitArray} password The password or key.\n     * @param {Object} ciphertext The cipher raw data to decrypt.\n     * @param {Object} [params] Additional non-default parameters.\n     * @param {Object} [rp] A returned object with filled parameters.\n     * @return {String} The plaintext.\n     * @throws {sjcl.exception.invalid} if a parameter is invalid.\n     * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n     */\n    _decrypt: function (password, ciphertext, params, rp) {\n        params = params || {};\n        rp = rp || {};\n        var j = sjcl.json, p = j._add(j._add(j._add({}, j.defaults), ciphertext), params, true), ct, tmp, prp, adata = p.adata;\n        if (typeof p.salt === \"string\") {\n            p.salt = sjcl.codec.base64.toBits(p.salt);\n        }\n        if (typeof p.iv === \"string\") {\n            p.iv = sjcl.codec.base64.toBits(p.iv);\n        }\n        if (!sjcl.mode[p.mode] ||\n            !sjcl.cipher[p.cipher] ||\n            (typeof password === \"string\" && p.iter <= 100) ||\n            (p.ts !== 64 && p.ts !== 96 && p.ts !== 128) ||\n            (p.ks !== 128 && p.ks !== 192 && p.ks !== 256) ||\n            (!p.iv) ||\n            (p.iv.length < 2 || p.iv.length > 4)) {\n            throw new sjcl.exception.invalid(\"json decrypt: invalid parameters\");\n        }\n        if (typeof password === \"string\") {\n            tmp = sjcl.misc.cachedPbkdf2(password, p);\n            password = tmp.key.slice(0, p.ks / 32);\n            p.salt = tmp.salt;\n        }\n        else if (sjcl.ecc && password instanceof sjcl.ecc.elGamal.secretKey) {\n            password = password.unkem(sjcl.codec.base64.toBits(p.kemtag)).slice(0, p.ks / 32);\n        }\n        if (typeof adata === \"string\") {\n            adata = sjcl.codec.utf8String.toBits(adata);\n        }\n        prp = new sjcl.cipher[p.cipher](password);\n        /* do the decryption */\n        if (p.mode === \"ccm\" && sjcl.arrayBuffer && sjcl.arrayBuffer.ccm && p.ct instanceof ArrayBuffer) {\n            ct = sjcl.arrayBuffer.ccm.decrypt(prp, p.ct, p.iv, p.tag, adata, p.ts);\n        }\n        else {\n            ct = sjcl.mode[p.mode].decrypt(prp, p.ct, p.iv, adata, p.ts);\n        }\n        /* return the json data */\n        j._add(rp, p);\n        rp.key = password;\n        if (params.raw === 1) {\n            return ct;\n        }\n        else {\n            return sjcl.codec.utf8String.fromBits(ct);\n        }\n    },\n    /** Simple decryption function.\n     * @param {String|bitArray} password The password or key.\n     * @param {String} ciphertext The ciphertext to decrypt.\n     * @param {Object} [params] Additional non-default parameters.\n     * @param {Object} [rp] A returned object with filled parameters.\n     * @return {String} The plaintext.\n     * @throws {sjcl.exception.invalid} if a parameter is invalid.\n     * @throws {sjcl.exception.corrupt} if the ciphertext is corrupt.\n     */\n    decrypt: function (password, ciphertext, params, rp) {\n        var j = sjcl.json;\n        return j._decrypt(password, j.decode(ciphertext), params, rp);\n    },\n    /** Encode a flat structure into a JSON string.\n     * @param {Object} obj The structure to encode.\n     * @return {String} A JSON string.\n     * @throws {sjcl.exception.invalid} if obj has a non-alphanumeric property.\n     * @throws {sjcl.exception.bug} if a parameter has an unsupported type.\n     */\n    encode: function (obj) {\n        var i, out = '{', comma = '';\n        for (i in obj) {\n            if (obj.hasOwnProperty(i)) {\n                if (!i.match(/^[a-z0-9]+$/i)) {\n                    throw new sjcl.exception.invalid(\"json encode: invalid property name\");\n                }\n                out += comma + '\"' + i + '\":';\n                comma = ',';\n                switch (typeof obj[i]) {\n                    case 'number':\n                    case 'boolean':\n                        out += obj[i];\n                        break;\n                    case 'string':\n                        out += '\"' + escape(obj[i]) + '\"';\n                        break;\n                    case 'object':\n                        out += '\"' + sjcl.codec.base64.fromBits(obj[i], 0) + '\"';\n                        break;\n                    default:\n                        throw new sjcl.exception.bug(\"json encode: unsupported type\");\n                }\n            }\n        }\n        return out + '}';\n    },\n    /** Decode a simple (flat) JSON string into a structure.  The ciphertext,\n     * adata, salt and iv will be base64-decoded.\n     * @param {String} str The string.\n     * @return {Object} The decoded structure.\n     * @throws {sjcl.exception.invalid} if str isn't (simple) JSON.\n     */\n    decode: function (str) {\n        str = str.replace(/\\s/g, '');\n        if (!str.match(/^\\{.*\\}$/)) {\n            throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n        }\n        var a = str.replace(/^\\{|\\}$/g, '').split(/,/), out = {}, i, m;\n        for (i = 0; i < a.length; i++) {\n            if (!(m = a[i].match(/^\\s*(?:([\"']?)([a-z][a-z0-9]*)\\1)\\s*:\\s*(?:(-?\\d+)|\"([a-z0-9+\\/%*_.@=\\-]*)\"|(true|false))$/i))) {\n                throw new sjcl.exception.invalid(\"json decode: this isn't json!\");\n            }\n            if (m[3] != null) {\n                out[m[2]] = parseInt(m[3], 10);\n            }\n            else if (m[4] != null) {\n                out[m[2]] = m[2].match(/^(ct|adata|salt|iv)$/) ? sjcl.codec.base64.toBits(m[4]) : unescape(m[4]);\n            }\n            else if (m[5] != null) {\n                out[m[2]] = m[5] === 'true';\n            }\n        }\n        return out;\n    },\n    /** Insert all elements of src into target, modifying and returning target.\n     * @param {Object} target The object to be modified.\n     * @param {Object} src The object to pull data from.\n     * @param {boolean} [requireSame=false] If true, throw an exception if any field of target differs from corresponding field of src.\n     * @return {Object} target.\n     * @private\n     */\n    _add: function (target, src, requireSame) {\n        if (target === undefined) {\n            target = {};\n        }\n        if (src === undefined) {\n            return target;\n        }\n        var i;\n        for (i in src) {\n            if (src.hasOwnProperty(i)) {\n                if (requireSame && target[i] !== undefined && target[i] !== src[i]) {\n                    throw new sjcl.exception.invalid(\"required parameter overridden\");\n                }\n                target[i] = src[i];\n            }\n        }\n        return target;\n    },\n    /** Remove all elements of minus from plus.  Does not modify plus.\n     * @private\n     */\n    _subtract: function (plus, minus) {\n        var out = {}, i;\n        for (i in plus) {\n            if (plus.hasOwnProperty(i) && plus[i] !== minus[i]) {\n                out[i] = plus[i];\n            }\n        }\n        return out;\n    },\n    /** Return only the specified elements of src.\n     * @private\n     */\n    _filter: function (src, filter) {\n        var out = {}, i;\n        for (i = 0; i < filter.length; i++) {\n            if (src[filter[i]] !== undefined) {\n                out[filter[i]] = src[filter[i]];\n            }\n        }\n        return out;\n    }\n};\n/** Simple encryption function; convenient shorthand for sjcl.json.encrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} plaintext The data to encrypt.\n * @param {Object} [params] The parameters including tag, iv and salt.\n * @param {Object} [rp] A returned version with filled-in parameters.\n * @return {String} The ciphertext.\n */\nsjcl.encrypt = sjcl.json.encrypt;\n/** Simple decryption function; convenient shorthand for sjcl.json.decrypt.\n * @param {String|bitArray} password The password or key.\n * @param {String} ciphertext The ciphertext to decrypt.\n * @param {Object} [params] Additional non-default parameters.\n * @param {Object} [rp] A returned object with filled parameters.\n * @return {String} The plaintext.\n */\nsjcl.decrypt = sjcl.json.decrypt;\n/** The cache for cachedPbkdf2.\n * @private\n */\nsjcl.misc._pbkdf2Cache = {};\n/** Cached PBKDF2 key derivation.\n * @param {String} password The password.\n * @param {Object} [obj] The derivation params (iteration count and optional salt).\n * @return {Object} The derived data in key, the salt in salt.\n */\nsjcl.misc.cachedPbkdf2 = function (password, obj) {\n    var cache = sjcl.misc._pbkdf2Cache, c, cp, str, salt, iter;\n    obj = obj || {};\n    iter = obj.iter || 1000;\n    /* open the cache for this password and iteration count */\n    cp = cache[password] = cache[password] || {};\n    c = cp[iter] = cp[iter] || { firstSalt: (obj.salt && obj.salt.length) ?\n            obj.salt.slice(0) : sjcl.random.randomWords(2, 0) };\n    salt = (obj.salt === undefined) ? c.firstSalt : obj.salt;\n    c[salt] = c[salt] || sjcl.misc.pbkdf2(password, salt, obj.iter);\n    return { key: c[salt].slice(0), salt: salt.slice(0) };\n};\n// Thanks to Colin McRae and Jonathan Burns of ionic security\n// for reporting and fixing two bugs in this file!\n/**\n * Constructs a new bignum from another bignum, a number or a hex string.\n * @constructor\n */\nsjcl.bn = function (it) {\n    this.initWith(it);\n};\nsjcl.bn.prototype = {\n    radix: 24,\n    maxMul: 8,\n    _class: sjcl.bn,\n    copy: function () {\n        return new this._class(this);\n    },\n    /**\n     * Initializes this with it, either as a bn, a number, or a hex string.\n     */\n    initWith: function (it) {\n        var i = 0, k;\n        switch (typeof it) {\n            case \"object\":\n                this.limbs = it.limbs.slice(0);\n                break;\n            case \"number\":\n                this.limbs = [it];\n                this.normalize();\n                break;\n            case \"string\":\n                it = it.replace(/^0x/, '');\n                this.limbs = [];\n                // hack\n                k = this.radix / 4;\n                for (i = 0; i < it.length; i += k) {\n                    this.limbs.push(parseInt(it.substring(Math.max(it.length - i - k, 0), it.length - i), 16));\n                }\n                break;\n            default:\n                this.limbs = [0];\n        }\n        return this;\n    },\n    /**\n     * Returns true if \"this\" and \"that\" are equal.  Calls fullReduce().\n     * Equality test is in constant time.\n     */\n    equals: function (that) {\n        if (typeof that === \"number\") {\n            that = new this._class(that);\n        }\n        var difference = 0, i;\n        this.fullReduce();\n        that.fullReduce();\n        for (i = 0; i < this.limbs.length || i < that.limbs.length; i++) {\n            difference |= this.getLimb(i) ^ that.getLimb(i);\n        }\n        return (difference === 0);\n    },\n    /**\n     * Get the i'th limb of this, zero if i is too large.\n     */\n    getLimb: function (i) {\n        return (i >= this.limbs.length) ? 0 : this.limbs[i];\n    },\n    /**\n     * Constant time comparison function.\n     * Returns 1 if this >= that, or zero otherwise.\n     */\n    greaterEquals: function (that) {\n        if (typeof that === \"number\") {\n            that = new this._class(that);\n        }\n        var less = 0, greater = 0, i, a, b;\n        i = Math.max(this.limbs.length, that.limbs.length) - 1;\n        for (; i >= 0; i--) {\n            a = this.getLimb(i);\n            b = that.getLimb(i);\n            greater |= (b - a) & ~less;\n            less |= (a - b) & ~greater;\n        }\n        return (greater | ~less) >>> 31;\n    },\n    /**\n     * Convert to a hex string.\n     */\n    toString: function () {\n        this.fullReduce();\n        var out = \"\", i, s, l = this.limbs;\n        for (i = 0; i < this.limbs.length; i++) {\n            s = l[i].toString(16);\n            while (i < this.limbs.length - 1 && s.length < 6) {\n                s = \"0\" + s;\n            }\n            out = s + out;\n        }\n        return \"0x\" + out;\n    },\n    /** this += that.  Does not normalize. */\n    addM: function (that) {\n        if (typeof (that) !== \"object\") {\n            that = new this._class(that);\n        }\n        var i, l = this.limbs, ll = that.limbs;\n        for (i = l.length; i < ll.length; i++) {\n            l[i] = 0;\n        }\n        for (i = 0; i < ll.length; i++) {\n            l[i] += ll[i];\n        }\n        return this;\n    },\n    /** this *= 2.  Requires normalized; ends up normalized. */\n    doubleM: function () {\n        var i, carry = 0, tmp, r = this.radix, m = this.radixMask, l = this.limbs;\n        for (i = 0; i < l.length; i++) {\n            tmp = l[i];\n            tmp = tmp + tmp + carry;\n            l[i] = tmp & m;\n            carry = tmp >> r;\n        }\n        if (carry) {\n            l.push(carry);\n        }\n        return this;\n    },\n    /** this /= 2, rounded down.  Requires normalized; ends up normalized. */\n    halveM: function () {\n        var i, carry = 0, tmp, r = this.radix, l = this.limbs;\n        for (i = l.length - 1; i >= 0; i--) {\n            tmp = l[i];\n            l[i] = (tmp + carry) >> 1;\n            carry = (tmp & 1) << r;\n        }\n        if (!l[l.length - 1]) {\n            l.pop();\n        }\n        return this;\n    },\n    /** this -= that.  Does not normalize. */\n    subM: function (that) {\n        if (typeof (that) !== \"object\") {\n            that = new this._class(that);\n        }\n        var i, l = this.limbs, ll = that.limbs;\n        for (i = l.length; i < ll.length; i++) {\n            l[i] = 0;\n        }\n        for (i = 0; i < ll.length; i++) {\n            l[i] -= ll[i];\n        }\n        return this;\n    },\n    mod: function (that) {\n        var neg = !this.greaterEquals(new sjcl.bn(0));\n        that = new sjcl.bn(that).normalize(); // copy before we begin\n        var out = new sjcl.bn(this).normalize(), ci = 0;\n        if (neg)\n            out = (new sjcl.bn(0)).subM(out).normalize();\n        for (; out.greaterEquals(that); ci++) {\n            that.doubleM();\n        }\n        if (neg)\n            out = that.sub(out).normalize();\n        for (; ci > 0; ci--) {\n            that.halveM();\n            if (out.greaterEquals(that)) {\n                out.subM(that).normalize();\n            }\n        }\n        return out.trim();\n    },\n    /** return inverse mod prime p.  p must be odd. Binary extended Euclidean algorithm mod p. */\n    inverseMod: function (p) {\n        var a = new sjcl.bn(1), b = new sjcl.bn(0), x = new sjcl.bn(this), y = new sjcl.bn(p), tmp, i, nz = 1;\n        if (!(p.limbs[0] & 1)) {\n            throw (new sjcl.exception.invalid(\"inverseMod: p must be odd\"));\n        }\n        // invariant: y is odd\n        do {\n            if (x.limbs[0] & 1) {\n                if (!x.greaterEquals(y)) {\n                    // x < y; swap everything\n                    tmp = x;\n                    x = y;\n                    y = tmp;\n                    tmp = a;\n                    a = b;\n                    b = tmp;\n                }\n                x.subM(y);\n                x.normalize();\n                if (!a.greaterEquals(b)) {\n                    a.addM(p);\n                }\n                a.subM(b);\n            }\n            // cut everything in half\n            x.halveM();\n            if (a.limbs[0] & 1) {\n                a.addM(p);\n            }\n            a.normalize();\n            a.halveM();\n            // check for termination: x ?= 0\n            for (i = nz = 0; i < x.limbs.length; i++) {\n                nz |= x.limbs[i];\n            }\n        } while (nz);\n        if (!y.equals(1)) {\n            throw (new sjcl.exception.invalid(\"inverseMod: p and x must be relatively prime\"));\n        }\n        return b;\n    },\n    /** this + that.  Does not normalize. */\n    add: function (that) {\n        return this.copy().addM(that);\n    },\n    /** this - that.  Does not normalize. */\n    sub: function (that) {\n        return this.copy().subM(that);\n    },\n    /** this * that.  Normalizes and reduces. */\n    mul: function (that) {\n        if (typeof (that) === \"number\") {\n            that = new this._class(that);\n        }\n        else {\n            that.normalize();\n        }\n        this.normalize();\n        var i, j, a = this.limbs, b = that.limbs, al = a.length, bl = b.length, out = new this._class(), c = out.limbs, ai, ii = this.maxMul;\n        for (i = 0; i < this.limbs.length + that.limbs.length + 1; i++) {\n            c[i] = 0;\n        }\n        for (i = 0; i < al; i++) {\n            ai = a[i];\n            for (j = 0; j < bl; j++) {\n                c[i + j] += ai * b[j];\n            }\n            if (!--ii) {\n                ii = this.maxMul;\n                out.cnormalize();\n            }\n        }\n        return out.cnormalize().reduce();\n    },\n    /** this ^ 2.  Normalizes and reduces. */\n    square: function () {\n        return this.mul(this);\n    },\n    /** this ^ n.  Uses square-and-multiply.  Normalizes and reduces. */\n    power: function (l) {\n        l = new sjcl.bn(l).normalize().trim().limbs;\n        var i, j, out = new this._class(1), pow = this;\n        for (i = 0; i < l.length; i++) {\n            for (j = 0; j < this.radix; j++) {\n                if (l[i] & (1 << j)) {\n                    out = out.mul(pow);\n                }\n                if (i == (l.length - 1) && l[i] >> (j + 1) == 0) {\n                    break;\n                }\n                pow = pow.square();\n            }\n        }\n        return out;\n    },\n    /** this * that mod N */\n    mulmod: function (that, N) {\n        return this.mod(N).mul(that.mod(N)).mod(N);\n    },\n    /** this ^ x mod N */\n    powermod: function (x, N) {\n        x = new sjcl.bn(x);\n        N = new sjcl.bn(N);\n        // Jump to montpowermod if possible.\n        if ((N.limbs[0] & 1) == 1) {\n            var montOut = this.montpowermod(x, N);\n            if (montOut != false) {\n                return montOut;\n            } // else go to slow powermod\n        }\n        var i, j, l = x.normalize().trim().limbs, out = new this._class(1), pow = this;\n        for (i = 0; i < l.length; i++) {\n            for (j = 0; j < this.radix; j++) {\n                if (l[i] & (1 << j)) {\n                    out = out.mulmod(pow, N);\n                }\n                if (i == (l.length - 1) && l[i] >> (j + 1) == 0) {\n                    break;\n                }\n                pow = pow.mulmod(pow, N);\n            }\n        }\n        return out;\n    },\n    /** this ^ x mod N with Montomery reduction */\n    montpowermod: function (x, N) {\n        x = new sjcl.bn(x).normalize().trim();\n        N = new sjcl.bn(N);\n        var i, j, radix = this.radix, out = new this._class(1), pow = this.copy();\n        // Generate R as a cap of N.\n        var R, s, wind, bitsize = x.bitLength();\n        R = new sjcl.bn({\n            limbs: N.copy().normalize().trim().limbs.map(function () { return 0; })\n        });\n        for (s = this.radix; s > 0; s--) {\n            if (((N.limbs[N.limbs.length - 1] >> s) & 1) == 1) {\n                R.limbs[R.limbs.length - 1] = 1 << s;\n                break;\n            }\n        }\n        // Calculate window size as a function of the exponent's size.\n        if (bitsize == 0) {\n            return this;\n        }\n        else if (bitsize < 18) {\n            wind = 1;\n        }\n        else if (bitsize < 48) {\n            wind = 3;\n        }\n        else if (bitsize < 144) {\n            wind = 4;\n        }\n        else if (bitsize < 768) {\n            wind = 5;\n        }\n        else {\n            wind = 6;\n        }\n        // Find R' and N' such that R * R' - N * N' = 1.\n        var RR = R.copy(), NN = N.copy(), RP = new sjcl.bn(1), NP = new sjcl.bn(0), RT = R.copy();\n        while (RT.greaterEquals(1)) {\n            RT.halveM();\n            if ((RP.limbs[0] & 1) == 0) {\n                RP.halveM();\n                NP.halveM();\n            }\n            else {\n                RP.addM(NN);\n                RP.halveM();\n                NP.halveM();\n                NP.addM(RR);\n            }\n        }\n        RP = RP.normalize();\n        NP = NP.normalize();\n        RR.doubleM();\n        var R2 = RR.mulmod(RR, N);\n        // Check whether the invariant holds.\n        // If it doesn't, we can't use Montgomery reduction on this modulus.\n        if (!RR.mul(RP).sub(N.mul(NP)).equals(1)) {\n            return false;\n        }\n        var montIn = function (c) { return montMul(c, R2); }, montMul = function (a, b) {\n            // Standard Montgomery reduction\n            var k, ab, right, abBar, mask = (1 << (s + 1)) - 1;\n            ab = a.mul(b);\n            right = ab.mul(NP);\n            right.limbs = right.limbs.slice(0, R.limbs.length);\n            if (right.limbs.length == R.limbs.length) {\n                right.limbs[R.limbs.length - 1] &= mask;\n            }\n            right = right.mul(N);\n            abBar = ab.add(right).normalize().trim();\n            abBar.limbs = abBar.limbs.slice(R.limbs.length - 1);\n            // Division.  Equivelent to calling *.halveM() s times.\n            for (k = 0; k < abBar.limbs.length; k++) {\n                if (k > 0) {\n                    abBar.limbs[k - 1] |= (abBar.limbs[k] & mask) << (radix - s - 1);\n                }\n                abBar.limbs[k] = abBar.limbs[k] >> (s + 1);\n            }\n            if (abBar.greaterEquals(N)) {\n                abBar.subM(N);\n            }\n            return abBar;\n        }, montOut = function (c) { return montMul(c, 1); };\n        pow = montIn(pow);\n        out = montIn(out);\n        // Sliding-Window Exponentiation (HAC 14.85)\n        var h, precomp = {}, cap = (1 << (wind - 1)) - 1;\n        precomp[1] = pow.copy();\n        precomp[2] = montMul(pow, pow);\n        for (h = 1; h <= cap; h++) {\n            precomp[(2 * h) + 1] = montMul(precomp[(2 * h) - 1], precomp[2]);\n        }\n        var getBit = function (exp, i) {\n            var off = i % exp.radix;\n            return (exp.limbs[Math.floor(i / exp.radix)] & (1 << off)) >> off;\n        };\n        for (i = x.bitLength() - 1; i >= 0;) {\n            if (getBit(x, i) == 0) {\n                // If the next bit is zero:\n                //   Square, move forward one bit.\n                out = montMul(out, out);\n                i = i - 1;\n            }\n            else {\n                // If the next bit is one:\n                //   Find the longest sequence of bits after this one, less than `wind`\n                //   bits long, that ends with a 1.  Convert the sequence into an\n                //   integer and look up the pre-computed value to add.\n                var l = i - wind + 1;\n                while (getBit(x, l) == 0) {\n                    l++;\n                }\n                var indx = 0;\n                for (j = l; j <= i; j++) {\n                    indx += getBit(x, j) << (j - l);\n                    out = montMul(out, out);\n                }\n                out = montMul(out, precomp[indx]);\n                i = l - 1;\n            }\n        }\n        return montOut(out);\n    },\n    trim: function () {\n        var l = this.limbs, p;\n        do {\n            p = l.pop();\n        } while (l.length && p === 0);\n        l.push(p);\n        return this;\n    },\n    /** Reduce mod a modulus.  Stubbed for subclassing. */\n    reduce: function () {\n        return this;\n    },\n    /** Reduce and normalize. */\n    fullReduce: function () {\n        return this.normalize();\n    },\n    /** Propagate carries. */\n    normalize: function () {\n        var carry = 0, i, pv = this.placeVal, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n        for (i = 0; i < ll || (carry !== 0 && carry !== -1); i++) {\n            l = (limbs[i] || 0) + carry;\n            m = limbs[i] = l & mask;\n            carry = (l - m) * ipv;\n        }\n        if (carry === -1) {\n            limbs[i - 1] -= pv;\n        }\n        this.trim();\n        return this;\n    },\n    /** Constant-time normalize. Does not allocate additional space. */\n    cnormalize: function () {\n        var carry = 0, i, ipv = this.ipv, l, m, limbs = this.limbs, ll = limbs.length, mask = this.radixMask;\n        for (i = 0; i < ll - 1; i++) {\n            l = limbs[i] + carry;\n            m = limbs[i] = l & mask;\n            carry = (l - m) * ipv;\n        }\n        limbs[i] += carry;\n        return this;\n    },\n    /** Serialize to a bit array */\n    toBits: function (len) {\n        this.fullReduce();\n        len = len || this.exponent || this.bitLength();\n        var i = Math.floor((len - 1) / 24), w = sjcl.bitArray, e = (len + 7 & -8) % this.radix || this.radix, out = [w.partial(e, this.getLimb(i))];\n        for (i--; i >= 0; i--) {\n            out = w.concat(out, [w.partial(Math.min(this.radix, len), this.getLimb(i))]);\n            len -= this.radix;\n        }\n        return out;\n    },\n    /** Return the length in bits, rounded up to the nearest byte. */\n    bitLength: function () {\n        this.fullReduce();\n        var out = this.radix * (this.limbs.length - 1), b = this.limbs[this.limbs.length - 1];\n        for (; b; b >>>= 1) {\n            out++;\n        }\n        return out + 7 & -8;\n    }\n};\n/** @memberOf sjcl.bn\n* @this { sjcl.bn }\n*/\nsjcl.bn.fromBits = function (bits) {\n    var Class = this, out = new Class(), words = [], w = sjcl.bitArray, t = this.prototype, l = Math.min(this.bitLength || 0x100000000, w.bitLength(bits)), e = l % t.radix || t.radix;\n    words[0] = w.extract(bits, 0, e);\n    for (; e < l; e += t.radix) {\n        words.unshift(w.extract(bits, e, t.radix));\n    }\n    out.limbs = words;\n    return out;\n};\nsjcl.bn.prototype.ipv = 1 / (sjcl.bn.prototype.placeVal = Math.pow(2, sjcl.bn.prototype.radix));\nsjcl.bn.prototype.radixMask = (1 << sjcl.bn.prototype.radix) - 1;\n/**\n * Creates a new subclass of bn, based on reduction modulo a pseudo-Mersenne prime,\n * i.e. a prime of the form 2^e + sum(a * 2^b),where the sum is negative and sparse.\n */\nsjcl.bn.pseudoMersennePrime = function (exponent, coeff) {\n    /** @constructor\n    * @private\n    */\n    function p(it) {\n        this.initWith(it);\n        /*if (this.limbs[this.modOffset]) {\n          this.reduce();\n        }*/\n    }\n    var ppr = p.prototype = new sjcl.bn(), i, tmp, mo;\n    mo = ppr.modOffset = Math.ceil(tmp = exponent / ppr.radix);\n    ppr.exponent = exponent;\n    ppr.offset = [];\n    ppr.factor = [];\n    ppr.minOffset = mo;\n    ppr.fullMask = 0;\n    ppr.fullOffset = [];\n    ppr.fullFactor = [];\n    ppr.modulus = p.modulus = new sjcl.bn(Math.pow(2, exponent));\n    ppr.fullMask = 0 | -Math.pow(2, exponent % ppr.radix);\n    for (i = 0; i < coeff.length; i++) {\n        ppr.offset[i] = Math.floor(coeff[i][0] / ppr.radix - tmp);\n        ppr.fullOffset[i] = Math.floor(coeff[i][0] / ppr.radix) - mo + 1;\n        ppr.factor[i] = coeff[i][1] * Math.pow(1 / 2, exponent - coeff[i][0] + ppr.offset[i] * ppr.radix);\n        ppr.fullFactor[i] = coeff[i][1] * Math.pow(1 / 2, exponent - coeff[i][0] + ppr.fullOffset[i] * ppr.radix);\n        ppr.modulus.addM(new sjcl.bn(Math.pow(2, coeff[i][0]) * coeff[i][1]));\n        ppr.minOffset = Math.min(ppr.minOffset, -ppr.offset[i]); // conservative\n    }\n    ppr._class = p;\n    ppr.modulus.cnormalize();\n    /** Approximate reduction mod p.  May leave a number which is negative or slightly larger than p.\n     * @memberof sjcl.bn\n     * @this { sjcl.bn }\n     */\n    ppr.reduce = function () {\n        var i, k, l, mo = this.modOffset, limbs = this.limbs, off = this.offset, ol = this.offset.length, fac = this.factor, ll;\n        i = this.minOffset;\n        while (limbs.length > mo) {\n            l = limbs.pop();\n            ll = limbs.length;\n            for (k = 0; k < ol; k++) {\n                limbs[ll + off[k]] -= fac[k] * l;\n            }\n            i--;\n            if (!i) {\n                limbs.push(0);\n                this.cnormalize();\n                i = this.minOffset;\n            }\n        }\n        this.cnormalize();\n        return this;\n    };\n    /** @memberof sjcl.bn\n    * @this { sjcl.bn }\n    */\n    ppr._strongReduce = (ppr.fullMask === -1) ? ppr.reduce : function () {\n        var limbs = this.limbs, i = limbs.length - 1, k, l;\n        this.reduce();\n        if (i === this.modOffset - 1) {\n            l = limbs[i] & this.fullMask;\n            limbs[i] -= l;\n            for (k = 0; k < this.fullOffset.length; k++) {\n                limbs[i + this.fullOffset[k]] -= this.fullFactor[k] * l;\n            }\n            this.normalize();\n        }\n    };\n    /** mostly constant-time, very expensive full reduction.\n     * @memberof sjcl.bn\n     * @this { sjcl.bn }\n     */\n    ppr.fullReduce = function () {\n        var greater, i;\n        // massively above the modulus, may be negative\n        this._strongReduce();\n        // less than twice the modulus, may be negative\n        this.addM(this.modulus);\n        this.addM(this.modulus);\n        this.normalize();\n        // probably 2-3x the modulus\n        this._strongReduce();\n        // less than the power of 2.  still may be more than\n        // the modulus\n        // HACK: pad out to this length\n        for (i = this.limbs.length; i < this.modOffset; i++) {\n            this.limbs[i] = 0;\n        }\n        // constant-time subtract modulus\n        greater = this.greaterEquals(this.modulus);\n        for (i = 0; i < this.limbs.length; i++) {\n            this.limbs[i] -= this.modulus.limbs[i] * greater;\n        }\n        this.cnormalize();\n        return this;\n    };\n    /** @memberof sjcl.bn\n    * @this { sjcl.bn }\n    */\n    ppr.inverse = function () {\n        return (this.power(this.modulus.sub(2)));\n    };\n    p.fromBits = sjcl.bn.fromBits;\n    return p;\n};\n// a small Mersenne prime\nvar sbp = sjcl.bn.pseudoMersennePrime;\nsjcl.bn.prime = {\n    p127: sbp(127, [[0, -1]]),\n    // Bernstein's prime for Curve25519\n    p25519: sbp(255, [[0, -19]]),\n    // Koblitz primes\n    p192k: sbp(192, [[32, -1], [12, -1], [8, -1], [7, -1], [6, -1], [3, -1], [0, -1]]),\n    p224k: sbp(224, [[32, -1], [12, -1], [11, -1], [9, -1], [7, -1], [4, -1], [1, -1], [0, -1]]),\n    p256k: sbp(256, [[32, -1], [9, -1], [8, -1], [7, -1], [6, -1], [4, -1], [0, -1]]),\n    // NIST primes\n    p192: sbp(192, [[0, -1], [64, -1]]),\n    p224: sbp(224, [[0, 1], [96, -1]]),\n    p256: sbp(256, [[0, -1], [96, 1], [192, 1], [224, -1]]),\n    p384: sbp(384, [[0, -1], [32, 1], [96, -1], [128, -1]]),\n    p521: sbp(521, [[0, -1]])\n};\nsjcl.bn.random = function (modulus, paranoia) {\n    if (typeof modulus !== \"object\") {\n        modulus = new sjcl.bn(modulus);\n    }\n    var words, i, l = modulus.limbs.length, m = modulus.limbs[l - 1] + 1, out = new sjcl.bn();\n    while (true) {\n        // get a sequence whose first digits make sense\n        do {\n            words = sjcl.random.randomWords(l, paranoia);\n            if (words[l - 1] < 0) {\n                words[l - 1] += 0x100000000;\n            }\n        } while (Math.floor(words[l - 1] / m) === Math.floor(0x100000000 / m));\n        words[l - 1] %= m;\n        // mask off all the limbs\n        for (i = 0; i < l - 1; i++) {\n            words[i] &= modulus.radixMask;\n        }\n        // check the rest of the digitssj\n        out.limbs = words;\n        if (!out.greaterEquals(modulus)) {\n            return out;\n        }\n    }\n};\n/**\n * base class for all ecc operations.\n * @namespace\n */\nsjcl.ecc = {};\n/**\n * Represents a point on a curve in affine coordinates.\n * @constructor\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n * @param {bigInt} x The x coordinate.\n * @param {bigInt} y The y coordinate.\n */\nsjcl.ecc.point = function (curve, x, y) {\n    if (x === undefined) {\n        this.isIdentity = true;\n    }\n    else {\n        if (x instanceof sjcl.bn) {\n            x = new curve.field(x);\n        }\n        if (y instanceof sjcl.bn) {\n            y = new curve.field(y);\n        }\n        this.x = x;\n        this.y = y;\n        this.isIdentity = false;\n    }\n    this.curve = curve;\n};\nsjcl.ecc.point.prototype = {\n    toJac: function () {\n        return new sjcl.ecc.pointJac(this.curve, this.x, this.y, new this.curve.field(1));\n    },\n    mult: function (k) {\n        return this.toJac().mult(k, this).toAffine();\n    },\n    /**\n     * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n     * @param {bigInt} k The coefficient to multiply this by.\n     * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n     * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n     * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n     */\n    mult2: function (k, k2, affine2) {\n        return this.toJac().mult2(k, this, k2, affine2).toAffine();\n    },\n    multiples: function () {\n        var m, i, j;\n        if (this._multiples === undefined) {\n            j = this.toJac().doubl();\n            m = this._multiples = [new sjcl.ecc.point(this.curve), this, j.toAffine()];\n            for (i = 3; i < 16; i++) {\n                j = j.add(this);\n                m.push(j.toAffine());\n            }\n        }\n        return this._multiples;\n    },\n    negate: function () {\n        var newY = new this.curve.field(0).sub(this.y).normalize().reduce();\n        return new sjcl.ecc.point(this.curve, this.x, newY);\n    },\n    isValid: function () {\n        return this.y.square().equals(this.curve.b.add(this.x.mul(this.curve.a.add(this.x.square()))));\n    },\n    toBits: function () {\n        return sjcl.bitArray.concat(this.x.toBits(), this.y.toBits());\n    }\n};\n/**\n * Represents a point on a curve in Jacobian coordinates. Coordinates can be specified as bigInts or strings (which\n * will be converted to bigInts).\n *\n * @constructor\n * @param {bigInt/string} x The x coordinate.\n * @param {bigInt/string} y The y coordinate.\n * @param {bigInt/string} z The z coordinate.\n * @param {sjcl.ecc.curve} curve The curve that this point lies on.\n */\nsjcl.ecc.pointJac = function (curve, x, y, z) {\n    if (x === undefined) {\n        this.isIdentity = true;\n    }\n    else {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.isIdentity = false;\n    }\n    this.curve = curve;\n};\nsjcl.ecc.pointJac.prototype = {\n    /**\n     * Adds S and T and returns the result in Jacobian coordinates. Note that S must be in Jacobian coordinates and T must be in affine coordinates.\n     * @param {sjcl.ecc.pointJac} S One of the points to add, in Jacobian coordinates.\n     * @param {sjcl.ecc.point} T The other point to add, in affine coordinates.\n     * @return {sjcl.ecc.pointJac} The sum of the two points, in Jacobian coordinates.\n     */\n    add: function (T) {\n        var S = this, sz2, c, d, c2, x1, x2, x, y1, y2, y, z;\n        if (S.curve !== T.curve) {\n            throw new sjcl.exception.invalid(\"sjcl.ecc.add(): Points must be on the same curve to add them!\");\n        }\n        if (S.isIdentity) {\n            return T.toJac();\n        }\n        else if (T.isIdentity) {\n            return S;\n        }\n        sz2 = S.z.square();\n        c = T.x.mul(sz2).subM(S.x);\n        if (c.equals(0)) {\n            if (S.y.equals(T.y.mul(sz2.mul(S.z)))) {\n                // same point\n                return S.doubl();\n            }\n            else {\n                // inverses\n                return new sjcl.ecc.pointJac(S.curve);\n            }\n        }\n        d = T.y.mul(sz2.mul(S.z)).subM(S.y);\n        c2 = c.square();\n        x1 = d.square();\n        x2 = c.square().mul(c).addM(S.x.add(S.x).mul(c2));\n        x = x1.subM(x2);\n        y1 = S.x.mul(c2).subM(x).mul(d);\n        y2 = S.y.mul(c.square().mul(c));\n        y = y1.subM(y2);\n        z = S.z.mul(c);\n        return new sjcl.ecc.pointJac(this.curve, x, y, z);\n    },\n    /**\n     * doubles this point.\n     * @return {sjcl.ecc.pointJac} The doubled point.\n     */\n    doubl: function () {\n        if (this.isIdentity) {\n            return this;\n        }\n        var y2 = this.y.square(), a = y2.mul(this.x.mul(4)), b = y2.square().mul(8), z2 = this.z.square(), c = this.curve.a.toString() == (new sjcl.bn(-3)).toString() ?\n            this.x.sub(z2).mul(3).mul(this.x.add(z2)) :\n            this.x.square().mul(3).add(z2.square().mul(this.curve.a)), x = c.square().subM(a).subM(a), y = a.sub(x).mul(c).subM(b), z = this.y.add(this.y).mul(this.z);\n        return new sjcl.ecc.pointJac(this.curve, x, y, z);\n    },\n    /**\n     * Returns a copy of this point converted to affine coordinates.\n     * @return {sjcl.ecc.point} The converted point.\n     */\n    toAffine: function () {\n        if (this.isIdentity || this.z.equals(0)) {\n            return new sjcl.ecc.point(this.curve);\n        }\n        var zi = this.z.inverse(), zi2 = zi.square();\n        return new sjcl.ecc.point(this.curve, this.x.mul(zi2).fullReduce(), this.y.mul(zi2.mul(zi)).fullReduce());\n    },\n    /**\n     * Multiply this point by k and return the answer in Jacobian coordinates.\n     * @param {bigInt} k The coefficient to multiply by.\n     * @param {sjcl.ecc.point} affine This point in affine coordinates.\n     * @return {sjcl.ecc.pointJac} The result of the multiplication, in Jacobian coordinates.\n     */\n    mult: function (k, affine) {\n        if (typeof (k) === \"number\") {\n            k = [k];\n        }\n        else if (k.limbs !== undefined) {\n            k = k.normalize().limbs;\n        }\n        var i, j, out = new sjcl.ecc.point(this.curve).toJac(), multiples = affine.multiples();\n        for (i = k.length - 1; i >= 0; i--) {\n            for (j = sjcl.bn.prototype.radix - 4; j >= 0; j -= 4) {\n                out = out.doubl().doubl().doubl().doubl().add(multiples[k[i] >> j & 0xF]);\n            }\n        }\n        return out;\n    },\n    /**\n     * Multiply this point by k, added to affine2*k2, and return the answer in Jacobian coordinates.\n     * @param {bigInt} k The coefficient to multiply this by.\n     * @param {sjcl.ecc.point} affine This point in affine coordinates.\n     * @param {bigInt} k2 The coefficient to multiply affine2 this by.\n     * @param {sjcl.ecc.point} affine The other point in affine coordinates.\n     * @return {sjcl.ecc.pointJac} The result of the multiplication and addition, in Jacobian coordinates.\n     */\n    mult2: function (k1, affine, k2, affine2) {\n        if (typeof (k1) === \"number\") {\n            k1 = [k1];\n        }\n        else if (k1.limbs !== undefined) {\n            k1 = k1.normalize().limbs;\n        }\n        if (typeof (k2) === \"number\") {\n            k2 = [k2];\n        }\n        else if (k2.limbs !== undefined) {\n            k2 = k2.normalize().limbs;\n        }\n        var i, j, out = new sjcl.ecc.point(this.curve).toJac(), m1 = affine.multiples(), m2 = affine2.multiples(), l1, l2;\n        for (i = Math.max(k1.length, k2.length) - 1; i >= 0; i--) {\n            l1 = k1[i] | 0;\n            l2 = k2[i] | 0;\n            for (j = sjcl.bn.prototype.radix - 4; j >= 0; j -= 4) {\n                out = out.doubl().doubl().doubl().doubl().add(m1[l1 >> j & 0xF]).add(m2[l2 >> j & 0xF]);\n            }\n        }\n        return out;\n    },\n    negate: function () {\n        return this.toAffine().negate().toJac();\n    },\n    isValid: function () {\n        var z2 = this.z.square(), z4 = z2.square(), z6 = z4.mul(z2);\n        return this.y.square().equals(this.curve.b.mul(z6).add(this.x.mul(this.curve.a.mul(z4).add(this.x.square()))));\n    }\n};\n/**\n * Construct an elliptic curve. Most users will not use this and instead start with one of the NIST curves defined below.\n *\n * @constructor\n * @param {bigInt} p The prime modulus.\n * @param {bigInt} r The prime order of the curve.\n * @param {bigInt} a The constant a in the equation of the curve y^2 = x^3 + ax + b (for NIST curves, a is always -3).\n * @param {bigInt} x The x coordinate of a base point of the curve.\n * @param {bigInt} y The y coordinate of a base point of the curve.\n */\nsjcl.ecc.curve = function (Field, r, a, b, x, y) {\n    this.field = Field;\n    this.r = new sjcl.bn(r);\n    this.a = new Field(a);\n    this.b = new Field(b);\n    this.G = new sjcl.ecc.point(this, new Field(x), new Field(y));\n};\nsjcl.ecc.curve.prototype.fromBits = function (bits) {\n    var w = sjcl.bitArray, l = this.field.prototype.exponent + 7 & -8, p = new sjcl.ecc.point(this, this.field.fromBits(w.bitSlice(bits, 0, l)), this.field.fromBits(w.bitSlice(bits, l, 2 * l)));\n    if (!p.isValid()) {\n        throw new sjcl.exception.corrupt(\"not on the curve!\");\n    }\n    return p;\n};\nsjcl.ecc.curves = {\n    c192: new sjcl.ecc.curve(sjcl.bn.prime.p192, \"0xffffffffffffffffffffffff99def836146bc9b1b4d22831\", -3, \"0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", \"0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", \"0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811\"),\n    c224: new sjcl.ecc.curve(sjcl.bn.prime.p224, \"0xffffffffffffffffffffffffffff16a2e0b8f03e13dd29455c5c2a3d\", -3, \"0xb4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", \"0xb70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", \"0xbd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\"),\n    c256: new sjcl.ecc.curve(sjcl.bn.prime.p256, \"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\", -3, \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", \"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", \"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n    c384: new sjcl.ecc.curve(sjcl.bn.prime.p384, \"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\", -3, \"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", \"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\", \"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\"),\n    c521: new sjcl.ecc.curve(sjcl.bn.prime.p521, \"0x1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\", -3, \"0x051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\", \"0xC6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\", \"0x11839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\"),\n    k192: new sjcl.ecc.curve(sjcl.bn.prime.p192k, \"0xfffffffffffffffffffffffe26f2fc170f69466a74defd8d\", 0, 3, \"0xdb4ff10ec057e9ae26b07d0280b7f4341da5d1b1eae06c7d\", \"0x9b2f2f6d9c5628a7844163d015be86344082aa88d95e2f9d\"),\n    k224: new sjcl.ecc.curve(sjcl.bn.prime.p224k, \"0x010000000000000000000000000001dce8d2ec6184caf0a971769fb1f7\", 0, 5, \"0xa1455b334df099df30fc28a169a467e9e47075a90f7e650eb6b7a45c\", \"0x7e089fed7fba344282cafbd6f7e319f7c0b0bd59e2ca4bdb556d61a5\"),\n    k256: new sjcl.ecc.curve(sjcl.bn.prime.p256k, \"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 0, 7, \"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\", \"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n};\nsjcl.ecc.curveName = function (curve) {\n    var curcurve;\n    for (curcurve in sjcl.ecc.curves) {\n        if (sjcl.ecc.curves.hasOwnProperty(curcurve)) {\n            if (sjcl.ecc.curves[curcurve] === curve) {\n                return curcurve;\n            }\n        }\n    }\n    throw new sjcl.exception.invalid(\"no such curve\");\n};\nsjcl.ecc.deserialize = function (key) {\n    var types = [\"elGamal\", \"ecdsa\"];\n    if (!key || !key.curve || !sjcl.ecc.curves[key.curve]) {\n        throw new sjcl.exception.invalid(\"invalid serialization\");\n    }\n    if (types.indexOf(key.type) === -1) {\n        throw new sjcl.exception.invalid(\"invalid type\");\n    }\n    var curve = sjcl.ecc.curves[key.curve];\n    if (key.secretKey) {\n        if (!key.exponent) {\n            throw new sjcl.exception.invalid(\"invalid exponent\");\n        }\n        var exponent = new sjcl.bn(key.exponent);\n        return new sjcl.ecc[key.type].secretKey(curve, exponent);\n    }\n    else {\n        if (!key.point) {\n            throw new sjcl.exception.invalid(\"invalid point\");\n        }\n        var point = curve.fromBits(sjcl.codec.hex.toBits(key.point));\n        return new sjcl.ecc[key.type].publicKey(curve, point);\n    }\n};\n/** our basicKey classes\n*/\nsjcl.ecc.basicKey = {\n    /** ecc publicKey.\n    * @constructor\n    * @param {curve} curve the elliptic curve\n    * @param {point} point the point on the curve\n    */\n    publicKey: function (curve, point) {\n        this._curve = curve;\n        this._curveBitLength = curve.r.bitLength();\n        if (point instanceof Array) {\n            this._point = curve.fromBits(point);\n        }\n        else {\n            this._point = point;\n        }\n        this.serialize = function () {\n            var curveName = sjcl.ecc.curveName(curve);\n            return {\n                type: this.getType(),\n                secretKey: false,\n                point: sjcl.codec.hex.fromBits(this._point.toBits()),\n                curve: curveName\n            };\n        };\n        /** get this keys point data\n        * @return x and y as bitArrays\n        */\n        this.get = function () {\n            var pointbits = this._point.toBits();\n            var len = sjcl.bitArray.bitLength(pointbits);\n            var x = sjcl.bitArray.bitSlice(pointbits, 0, len / 2);\n            var y = sjcl.bitArray.bitSlice(pointbits, len / 2);\n            return { x: x, y: y };\n        };\n    },\n    /** ecc secretKey\n    * @constructor\n    * @param {curve} curve the elliptic curve\n    * @param exponent\n    */\n    secretKey: function (curve, exponent) {\n        this._curve = curve;\n        this._curveBitLength = curve.r.bitLength();\n        this._exponent = exponent;\n        this.serialize = function () {\n            var exponent = this.get();\n            var curveName = sjcl.ecc.curveName(curve);\n            return {\n                type: this.getType(),\n                secretKey: true,\n                exponent: sjcl.codec.hex.fromBits(exponent),\n                curve: curveName\n            };\n        };\n        /** get this keys exponent data\n        * @return {bitArray} exponent\n        */\n        this.get = function () {\n            return this._exponent.toBits();\n        };\n    }\n};\n/** @private */\nsjcl.ecc.basicKey.generateKeys = function (cn) {\n    return function generateKeys(curve, paranoia, sec) {\n        curve = curve || 256;\n        if (typeof curve === \"number\") {\n            curve = sjcl.ecc.curves['c' + curve];\n            if (curve === undefined) {\n                throw new sjcl.exception.invalid(\"no such curve\");\n            }\n        }\n        sec = sec || sjcl.bn.random(curve.r, paranoia);\n        var pub = curve.G.mult(sec);\n        return { pub: new sjcl.ecc[cn].publicKey(curve, pub),\n            sec: new sjcl.ecc[cn].secretKey(curve, sec) };\n    };\n};\n/** elGamal keys */\nsjcl.ecc.elGamal = {\n    /** generate keys\n    * @function\n    * @param curve\n    * @param {int} paranoia Paranoia for generation (default 6)\n    * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n    */\n    generateKeys: sjcl.ecc.basicKey.generateKeys(\"elGamal\"),\n    /** elGamal publicKey.\n    * @constructor\n    * @augments sjcl.ecc.basicKey.publicKey\n    */\n    publicKey: function (curve, point) {\n        sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n    },\n    /** elGamal secretKey\n    * @constructor\n    * @augments sjcl.ecc.basicKey.secretKey\n    */\n    secretKey: function (curve, exponent) {\n        sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n    }\n};\nsjcl.ecc.elGamal.publicKey.prototype = {\n    /** Kem function of elGamal Public Key\n    * @param paranoia paranoia to use for randomization.\n    * @return {object} key and tag. unkem(tag) with the corresponding secret key results in the key returned.\n    */\n    kem: function (paranoia) {\n        var sec = sjcl.bn.random(this._curve.r, paranoia), tag = this._curve.G.mult(sec).toBits(), key = sjcl.hash.sha256.hash(this._point.mult(sec).toBits());\n        return { key: key, tag: tag };\n    },\n    getType: function () {\n        return \"elGamal\";\n    }\n};\nsjcl.ecc.elGamal.secretKey.prototype = {\n    /** UnKem function of elGamal Secret Key\n    * @param {bitArray} tag The Tag to decrypt.\n    * @return {bitArray} decrypted key.\n    */\n    unkem: function (tag) {\n        return sjcl.hash.sha256.hash(this._curve.fromBits(tag).mult(this._exponent).toBits());\n    },\n    /** Diffie-Hellmann function\n    * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with\n    * @return {bitArray} diffie-hellmann result for this key combination.\n    */\n    dh: function (pk) {\n        return sjcl.hash.sha256.hash(pk._point.mult(this._exponent).toBits());\n    },\n    /** Diffie-Hellmann function, compatible with Java generateSecret\n    * @param {elGamal.publicKey} pk The Public Key to do Diffie-Hellmann with\n    * @return {bitArray} undigested X value, diffie-hellmann result for this key combination,\n    * compatible with Java generateSecret().\n    */\n    dhJavaEc: function (pk) {\n        return pk._point.mult(this._exponent).x.toBits();\n    },\n    getType: function () {\n        return \"elGamal\";\n    }\n};\n/** ecdsa keys */\nsjcl.ecc.ecdsa = {\n    /** generate keys\n    * @function\n    * @param curve\n    * @param {int} paranoia Paranoia for generation (default 6)\n    * @param {secretKey} sec secret Key to use. used to get the publicKey for ones secretKey\n    */\n    generateKeys: sjcl.ecc.basicKey.generateKeys(\"ecdsa\")\n};\n/** ecdsa publicKey.\n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.publicKey = function (curve, point) {\n    sjcl.ecc.basicKey.publicKey.apply(this, arguments);\n};\n/** specific functions for ecdsa publicKey. */\nsjcl.ecc.ecdsa.publicKey.prototype = {\n    /** Diffie-Hellmann function\n    * @param {bitArray} hash hash to verify.\n    * @param {bitArray} rs signature bitArray.\n    * @param {boolean}  fakeLegacyVersion use old legacy version\n    */\n    verify: function (hash, rs, fakeLegacyVersion) {\n        if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n            hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n        }\n        var w = sjcl.bitArray, R = this._curve.r, l = this._curveBitLength, r = sjcl.bn.fromBits(w.bitSlice(rs, 0, l)), ss = sjcl.bn.fromBits(w.bitSlice(rs, l, 2 * l)), s = fakeLegacyVersion ? ss : ss.inverseMod(R), hG = sjcl.bn.fromBits(hash).mul(s).mod(R), hA = r.mul(s).mod(R), r2 = this._curve.G.mult2(hG, hA, this._point).x;\n        if (r.equals(0) || ss.equals(0) || r.greaterEquals(R) || ss.greaterEquals(R) || !r2.equals(r)) {\n            if (fakeLegacyVersion === undefined) {\n                return this.verify(hash, rs, true);\n            }\n            else {\n                throw (new sjcl.exception.corrupt(\"signature didn't check out\"));\n            }\n        }\n        return true;\n    },\n    getType: function () {\n        return \"ecdsa\";\n    }\n};\n/** ecdsa secretKey\n* @constructor\n* @augments sjcl.ecc.basicKey.publicKey\n*/\nsjcl.ecc.ecdsa.secretKey = function (curve, exponent) {\n    sjcl.ecc.basicKey.secretKey.apply(this, arguments);\n};\n/** specific functions for ecdsa secretKey. */\nsjcl.ecc.ecdsa.secretKey.prototype = {\n    /** Diffie-Hellmann function\n    * @param {bitArray} hash hash to sign.\n    * @param {int} paranoia paranoia for random number generation\n    * @param {boolean} fakeLegacyVersion use old legacy version\n    */\n    sign: function (hash, paranoia, fakeLegacyVersion, fixedKForTesting) {\n        if (sjcl.bitArray.bitLength(hash) > this._curveBitLength) {\n            hash = sjcl.bitArray.clamp(hash, this._curveBitLength);\n        }\n        var R = this._curve.r, l = R.bitLength(), k = fixedKForTesting || sjcl.bn.random(R.sub(1), paranoia).add(1), r = this._curve.G.mult(k).x.mod(R), ss = sjcl.bn.fromBits(hash).add(r.mul(this._exponent)), s = fakeLegacyVersion ? ss.inverseMod(R).mul(k).mod(R)\n            : ss.mul(k.inverseMod(R)).mod(R);\n        return sjcl.bitArray.concat(r.toBits(l), s.toBits(l));\n    },\n    getType: function () {\n        return \"ecdsa\";\n    }\n};\n/** @fileOverview Bit array codec implementations.\n *\n * @author Marco Munizaga\n */\n//patch arraybuffers if they don't exist\nif (typeof (ArrayBuffer) === 'undefined') {\n    (function (globals) {\n        \"use strict\";\n        globals.ArrayBuffer = function () { };\n        globals.DataView = function () { };\n    }(undefined));\n}\n/**\n * ArrayBuffer\n * @namespace\n */\nsjcl.codec.arrayBuffer = {\n    /** Convert from a bitArray to an ArrayBuffer.\n     * Will default to 8byte padding if padding is undefined*/\n    fromBits: function (arr, padding, padding_count) {\n        var out, i, ol, tmp, smallest;\n        padding = padding == undefined ? true : padding;\n        padding_count = padding_count || 8;\n        if (arr.length === 0) {\n            return new ArrayBuffer(0);\n        }\n        ol = sjcl.bitArray.bitLength(arr) / 8;\n        //check to make sure the bitLength is divisible by 8, if it isn't \n        //we can't do anything since arraybuffers work with bytes, not bits\n        if (sjcl.bitArray.bitLength(arr) % 8 !== 0) {\n            throw new sjcl.exception.invalid(\"Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly\");\n        }\n        if (padding && ol % padding_count !== 0) {\n            ol += padding_count - (ol % padding_count);\n        }\n        //padded temp for easy copying\n        tmp = new DataView(new ArrayBuffer(arr.length * 4));\n        for (i = 0; i < arr.length; i++) {\n            tmp.setUint32(i * 4, (arr[i] << 32)); //get rid of the higher bits\n        }\n        //now copy the final message if we are not going to 0 pad\n        out = new DataView(new ArrayBuffer(ol));\n        //save a step when the tmp and out bytelength are ===\n        if (out.byteLength === tmp.byteLength) {\n            return tmp.buffer;\n        }\n        smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;\n        for (i = 0; i < smallest; i++) {\n            out.setUint8(i, tmp.getUint8(i));\n        }\n        return out.buffer;\n    },\n    /** Convert from an ArrayBuffer to a bitArray. */\n    toBits: function (buffer) {\n        var i, out = [], len, inView, tmp;\n        if (buffer.byteLength === 0) {\n            return [];\n        }\n        inView = new DataView(buffer);\n        len = inView.byteLength - inView.byteLength % 4;\n        for (var i = 0; i < len; i += 4) {\n            out.push(inView.getUint32(i));\n        }\n        if (inView.byteLength % 4 != 0) {\n            tmp = new DataView(new ArrayBuffer(4));\n            for (var i = 0, l = inView.byteLength % 4; i < l; i++) {\n                //we want the data to the right, because partial slices off the starting bits\n                tmp.setUint8(i + 4 - l, inView.getUint8(len + i)); // big-endian, \n            }\n            out.push(sjcl.bitArray.partial((inView.byteLength % 4) * 8, tmp.getUint32(0)));\n        }\n        return out;\n    },\n    /** Prints a hex output of the buffer contents, akin to hexdump **/\n    hexDumpBuffer: function (buffer) {\n        var stringBufferView = new DataView(buffer);\n        var string = '';\n        var pad = function (n, width) {\n            n = n + '';\n            return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;\n        };\n        for (var i = 0; i < stringBufferView.byteLength; i += 2) {\n            if (i % 16 == 0)\n                string += ('\\n' + (i).toString(16) + '\\t');\n            string += (pad(stringBufferView.getUint16(i).toString(16), 4) + ' ');\n        }\n        if (typeof console === undefined) {\n            console = console || { log: function () { } }; //fix for IE\n        }\n        console.log(string.toUpperCase());\n    }\n};\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = sjcl;\n}\nif (typeof define === \"function\") {\n    define([], function () {\n        return sjcl;\n    });\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sjcl);\n\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/sjcl/index.js?\n}");

/***/ },

/***/ "./node_modules/@cloudflare/voprf-ts/lib/src/util.js"
/*!***********************************************************!*\
  !*** ./node_modules/@cloudflare/voprf-ts/lib/src/util.js ***!
  \***********************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ctEqual: () => (/* binding */ ctEqual),\n/* harmony export */   hashParams: () => (/* binding */ hashParams),\n/* harmony export */   joinAll: () => (/* binding */ joinAll),\n/* harmony export */   to16bits: () => (/* binding */ to16bits),\n/* harmony export */   xor: () => (/* binding */ xor)\n/* harmony export */ });\n// Copyright (c) 2021 Cloudflare, Inc. and contributors.\n// Copyright (c) 2021 Cloudflare, Inc.\n// Licensed under the BSD-3-Clause license found in the LICENSE file or\n// at https://opensource.org/licenses/BSD-3-Clause\nfunction joinAll(a) {\n    let size = 0;\n    for (let i = 0; i < a.length; i++) {\n        size += a[i].length;\n    }\n    const ret = new Uint8Array(new ArrayBuffer(size));\n    for (let i = 0, offset = 0; i < a.length; i++) {\n        ret.set(a[i], offset);\n        offset += a[i].length;\n    }\n    return ret;\n}\nfunction xor(a, b) {\n    if (a.length !== b.length || a.length === 0) {\n        throw new Error('arrays of different length');\n    }\n    const n = a.length, c = new Uint8Array(n);\n    for (let i = 0; i < n; i++) {\n        c[i] = a[i] ^ b[i];\n    }\n    return c;\n}\nfunction ctEqual(a, b) {\n    if (a.length !== b.length || a.length === 0) {\n        return false;\n    }\n    const n = a.length;\n    let c = 0;\n    for (let i = 0; i < n; i++) {\n        c |= a[i] ^ b[i];\n    }\n    return c === 0;\n}\nfunction to16bits(n) {\n    if (!(n >= 0 && n < 0xffff)) {\n        throw new Error('number bigger than 2^16');\n    }\n    return new Uint8Array([(n >> 8) & 0xff, n & 0xff]);\n}\nfunction hashParams(hash) {\n    switch (hash) {\n        case 'SHA-1':\n            return { outLenBytes: 20, blockLenBytes: 64 };\n        case 'SHA-256':\n            return { outLenBytes: 32, blockLenBytes: 64 };\n        case 'SHA-384':\n            return { outLenBytes: 48, blockLenBytes: 128 };\n        case 'SHA-512':\n            return { outLenBytes: 64, blockLenBytes: 128 };\n        default:\n            throw new Error(`invalid hash name: ${hash}`);\n    }\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://frontend/./node_modules/@cloudflare/voprf-ts/lib/src/util.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/_sha2.js"
/*!*****************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/_sha2.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/lib/esm/utils.js\");\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        const { view, buffer, blockLen, finished } = this;\n        if (finished)\n            throw new Error('digest() was already called');\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length < this.outputLen)\n            throw new Error('_Sha2: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // NOTE: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64bit of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/_sha2.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/cryptoBrowser.js"
/*!*************************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/cryptoBrowser.js ***!
  \*************************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = {\n    node: undefined,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/cryptoBrowser.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/hmac.js"
/*!****************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/hmac.js ***!
  \****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/lib/esm/utils.js\");\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assertHash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (!(this.iHash instanceof _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash))\n            throw new TypeError('Expected instance of class which extends utils.Hash');\n        const blockLen = (this.blockLen = this.iHash.blockLen);\n        this.outputLen = this.iHash.outputLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > this.iHash.blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        if (this.destroyed)\n            throw new Error('instance is destroyed');\n        if (!(out instanceof Uint8Array) || out.length !== this.outputLen)\n            throw new Error('HMAC: Invalid output buffer');\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\nhmac.init = hmac.create;\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/hmac.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/pbkdf2.js"
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/pbkdf2.js ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   pbkdf2Async: () => (/* binding */ pbkdf2Async)\n/* harmony export */ });\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/@noble/hashes/lib/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/lib/esm/utils.js\");\n\n// prettier-ignore\n\n// Common prologue and epilogue for sync/async functions\nfunction pbkdf2Init(hash, _password, _salt, _opts) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assertHash)(hash);\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);\n    const { c, dkLen, asyncTick } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(c);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(dkLen);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.assertNumber)(asyncTick);\n    if (c < 1)\n        throw new Error('PBKDF2: iterations (c) should be >= 1');\n    const password = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_password);\n    const salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_salt);\n    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);\n    const DK = new Uint8Array(dkLen);\n    // U1 = PRF(Password, Salt + INT_32_BE(i))\n    const PRF = _hmac_js__WEBPACK_IMPORTED_MODULE_0__.hmac.init(hash, password);\n    const PRFSalt = PRF._cloneInto().update(salt);\n    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };\n}\nfunction pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW)\n        prfW.destroy();\n    u.fill(0);\n    return DK;\n}\nfunction pbkdf2(hash, password, salt, _opts) {\n    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, _opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\nasync function pbkdf2Async(hash, password, salt, _opts) {\n    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, _opts);\n    let prfW; // Working copy\n    const arr = new Uint8Array(4);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    // DK = T1 + T2 +  + Tdklen/hlen\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        // Ti = F(Password, Salt, c, i)\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc\n        // U1 = PRF(Password, Salt + INT_32_BE(i))\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.asyncLoop)(c - 1, asyncTick, (i) => {\n            // Uc = PRF(Password, Uc1)\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        });\n    }\n    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);\n}\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/pbkdf2.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/scrypt.js"
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/scrypt.js ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   scrypt: () => (/* binding */ scrypt),\n/* harmony export */   scryptAsync: () => (/* binding */ scryptAsync)\n/* harmony export */ });\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha256.js */ \"./node_modules/@noble/hashes/lib/esm/sha256.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pbkdf2.js */ \"./node_modules/@noble/hashes/lib/esm/pbkdf2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/lib/esm/utils.js\");\n\n\n\n// Left rotate for uint32\nconst rotl = (a, b) => (a << b) | (a >>> (32 - b));\n// prettier-ignore\nfunction XorAndSalsa(prev, pi, input, ii, out, oi) {\n    // Based on https://cr.yp.to/salsa20.html\n    // Xor blocks\n    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];\n    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];\n    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];\n    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];\n    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];\n    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];\n    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];\n    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];\n    // Save state to temporary variables (salsa)\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    // Main loop (salsa)\n    for (let i = 0; i < 8; i += 2) {\n        x04 ^= rotl(x00 + x12 | 0, 7);\n        x08 ^= rotl(x04 + x00 | 0, 9);\n        x12 ^= rotl(x08 + x04 | 0, 13);\n        x00 ^= rotl(x12 + x08 | 0, 18);\n        x09 ^= rotl(x05 + x01 | 0, 7);\n        x13 ^= rotl(x09 + x05 | 0, 9);\n        x01 ^= rotl(x13 + x09 | 0, 13);\n        x05 ^= rotl(x01 + x13 | 0, 18);\n        x14 ^= rotl(x10 + x06 | 0, 7);\n        x02 ^= rotl(x14 + x10 | 0, 9);\n        x06 ^= rotl(x02 + x14 | 0, 13);\n        x10 ^= rotl(x06 + x02 | 0, 18);\n        x03 ^= rotl(x15 + x11 | 0, 7);\n        x07 ^= rotl(x03 + x15 | 0, 9);\n        x11 ^= rotl(x07 + x03 | 0, 13);\n        x15 ^= rotl(x11 + x07 | 0, 18);\n        x01 ^= rotl(x00 + x03 | 0, 7);\n        x02 ^= rotl(x01 + x00 | 0, 9);\n        x03 ^= rotl(x02 + x01 | 0, 13);\n        x00 ^= rotl(x03 + x02 | 0, 18);\n        x06 ^= rotl(x05 + x04 | 0, 7);\n        x07 ^= rotl(x06 + x05 | 0, 9);\n        x04 ^= rotl(x07 + x06 | 0, 13);\n        x05 ^= rotl(x04 + x07 | 0, 18);\n        x11 ^= rotl(x10 + x09 | 0, 7);\n        x08 ^= rotl(x11 + x10 | 0, 9);\n        x09 ^= rotl(x08 + x11 | 0, 13);\n        x10 ^= rotl(x09 + x08 | 0, 18);\n        x12 ^= rotl(x15 + x14 | 0, 7);\n        x13 ^= rotl(x12 + x15 | 0, 9);\n        x14 ^= rotl(x13 + x12 | 0, 13);\n        x15 ^= rotl(x14 + x13 | 0, 18);\n    }\n    // Write output (salsa)\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\nfunction BlockMix(input, ii, out, oi, r) {\n    // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)\n    let head = oi + 0;\n    let tail = oi + 16 * r;\n    for (let i = 0; i < 16; i++)\n        out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]\n    for (let i = 0; i < r; i++, head += 16, ii += 16) {\n        // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1\n        XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])\n        if (i > 0)\n            tail += 16; // First iteration overwrites tmp value in tail\n        XorAndSalsa(out, head, input, (ii += 16), out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])\n    }\n}\n// Common prologue and epilogue for sync/async functions\nfunction scryptInit(password, salt, _opts) {\n    // Maxmem - 1GB+1KB by default\n    const opts = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.checkOpts)({\n        dkLen: 32,\n        asyncTick: 10,\n        maxmem: 1024 ** 3 + 1024,\n    }, _opts);\n    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(N);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(r);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(p);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(dkLen);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(asyncTick);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.assertNumber)(maxmem);\n    if (onProgress !== undefined && typeof onProgress !== 'function')\n        throw new Error('progressCb should be function');\n    const blockSize = 128 * r;\n    const blockSize32 = blockSize / 4;\n    if (N <= 1 || (N & (N - 1)) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {\n        // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function\n        // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.\n        throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');\n    }\n    if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {\n        throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');\n    }\n    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {\n        throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');\n    }\n    const memUsed = blockSize * (N + p);\n    if (memUsed > maxmem) {\n        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);\n    }\n    // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)\n    // Since it has only one iteration there is no reason to use async variant\n    const B = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_0__.sha256, password, salt, { c: 1, dkLen: blockSize * p });\n    const B32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(B);\n    // Re-used between parallel iterations. Array(iterations) of B\n    const V = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(new Uint8Array(blockSize * N));\n    const tmp = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(new Uint8Array(blockSize));\n    let blockMixCb = () => { };\n    if (onProgress) {\n        const totalBlockMix = 2 * N * p;\n        // Invoke callback if progress changes from 10.01 to 10.02\n        // Allows to draw smooth progress bar on up to 8K screen\n        const callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);\n        let blockMixCnt = 0;\n        blockMixCb = () => {\n            blockMixCnt++;\n            if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))\n                onProgress(blockMixCnt / totalBlockMix);\n        };\n    }\n    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };\n}\nfunction scryptOutput(password, dkLen, B, V, tmp) {\n    const res = (0,_pbkdf2_js__WEBPACK_IMPORTED_MODULE_1__.pbkdf2)(_sha256_js__WEBPACK_IMPORTED_MODULE_0__.sha256, password, B, { c: 1, dkLen });\n    B.fill(0);\n    V.fill(0);\n    tmp.fill(0);\n    return res;\n}\nfunction scrypt(password, salt, _opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, _opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        for (let i = 0, pos = 0; i < N - 1; i++) {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        }\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        for (let i = 0; i < N; i++) {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        }\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\nasync function scryptAsync(password, salt, _opts) {\n    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, _opts);\n    for (let pi = 0; pi < p; pi++) {\n        const Pi = blockSize32 * pi;\n        for (let i = 0; i < blockSize32; i++)\n            V[i] = B32[Pi + i]; // V[0] = B[i]\n        let pos = 0;\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.asyncLoop)(N - 1, asyncTick, (i) => {\n            BlockMix(V, pos, V, (pos += blockSize32), r); // V[i] = BlockMix(V[i-1]);\n            blockMixCb();\n        });\n        BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element\n        blockMixCb();\n        await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.asyncLoop)(N, asyncTick, (i) => {\n            // First u32 of the last 64-byte block (u32 is LE)\n            const j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations\n            for (let k = 0; k < blockSize32; k++)\n                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]\n            BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])\n            blockMixCb();\n        });\n    }\n    return scryptOutput(password, dkLen, B, V, tmp);\n}\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/scrypt.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/sha256.js"
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/sha256.js ***!
  \******************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@noble/hashes/lib/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/lib/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/sha256.js?\n}");

/***/ },

/***/ "./node_modules/@noble/hashes/lib/esm/utils.js"
/*!*****************************************************!*\
  !*** ./node_modules/@noble/hashes/lib/esm/utils.js ***!
  \*****************************************************/
(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   assertBool: () => (/* binding */ assertBool),\n/* harmony export */   assertHash: () => (/* binding */ assertHash),\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_lib_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/lib/crypto */ \"./node_modules/@noble/hashes/lib/esm/cryptoBrowser.js\");\n/*! noble-hashes - MIT License (c) 2021 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.\n// So, just to be sure not to corrupt anything.\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    // pre-caching chars could speed this up 6x.\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\n// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)\n// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here\nconst nextTick = (() => {\n    const nodeRequire = typeof module !== 'undefined' &&\n        typeof module.require === 'function' &&\n        module.require.bind(module);\n    try {\n        if (nodeRequire) {\n            const { setImmediate } = nodeRequire('timers');\n            return () => new Promise((resolve) => setImmediate(resolve));\n        }\n    }\n    catch (e) { }\n    return () => new Promise((resolve) => setTimeout(resolve, 0));\n})();\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = new TextEncoder().encode(data);\n    if (!(data instanceof Uint8Array))\n        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);\n    return data;\n}\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction assertBool(b) {\n    if (typeof b !== 'boolean') {\n        throw new Error(`Expected boolean, not ${b}`);\n    }\n}\nfunction assertHash(hash) {\n    if (typeof hash !== 'function' || typeof hash.init !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    assertNumber(hash.outputLen);\n    assertNumber(hash.blockLen);\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(def, _opts) {\n    if (_opts !== undefined && (typeof _opts !== 'object' || !isPlainObject(_opts)))\n        throw new TypeError('Options should be object or undefined');\n    const opts = Object.assign(def, _opts);\n    return opts;\n}\nfunction wrapConstructor(hashConstructor) {\n    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();\n    const tmp = hashConstructor();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashConstructor();\n    hashC.init = hashC.create;\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    hashC.init = hashC.create;\n    return hashC;\n}\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web) {\n        return _noble_hashes_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    }\n    else if (_noble_hashes_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node) {\n        return new Uint8Array(_noble_hashes_lib_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.node.randomBytes(bytesLength).buffer);\n    }\n    else {\n        throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n}\n\n\n//# sourceURL=webpack://frontend/./node_modules/@noble/hashes/lib/esm/utils.js?\n}");

/***/ },

/***/ "./src/login.js"
/*!**********************!*\
  !*** ./src/login.js ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _opaque_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./opaque.js */ \"./src/opaque.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\n\nconst form = document.getElementById(\"loginForm\");\nconst errBox = document.getElementById(\"errorBox\");\n\nform.addEventListener(\"submit\", async (e) => {\n    e.preventDefault();\n\n    const password = form.password.value;\n    const username = form.username.value;\n\n    const opaque = new _opaque_js__WEBPACK_IMPORTED_MODULE_0__.OpaqueClientWrapper(\"cool-password-manager\");\n\n    try {\n        const ke1 = await opaque.loginInit(password);\n\n        const res1 = await fetch(\"/account/auth/login/init/\", {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                username,\n                ke1: (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.uint8ArrayToBase64)(ke1),\n            }),\n        });\n\n        const res1Data = await res1.json();\n        if (!res1.ok) {\n            errBox.innerHTML = res1Data.message;\n            return;\n        }\n\n    } catch (err) {\n        console.error(err);\n        errBox.innerHTML = \"Registration failed. See console for details.\";\n    }\n});\n\n//# sourceURL=webpack://frontend/./src/login.js?\n}");

/***/ },

/***/ "./src/opaque.js"
/*!***********************!*\
  !*** ./src/opaque.js ***!
  \***********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpaqueClientWrapper: () => (/* binding */ OpaqueClientWrapper)\n/* harmony export */ });\n/* harmony import */ var _cloudflare_opaque_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cloudflare/opaque-ts */ \"./node_modules/@cloudflare/opaque-ts/lib/src/index.js\");\n// opaqueClient.js\n\n\nconst encoder = new TextEncoder();\n\nclass OpaqueClientWrapper {\n    constructor(serverIdentity) {\n        this.cfg = (0,_cloudflare_opaque_ts__WEBPACK_IMPORTED_MODULE_0__.getOpaqueConfig)(3);\n        this.client = new _cloudflare_opaque_ts__WEBPACK_IMPORTED_MODULE_0__.OpaqueClient(this.cfg);\n        this.state = null;\n        this.serverIdentity = serverIdentity\n    }\n\n    async registerInit(password) {\n        const registrationRequest = await this.client.registerInit(password)\n        return registrationRequest.serialize()\n    }\n\n    async registerFinish(serverResponseBytes, clientIdentity) {\n        const deserRes = _cloudflare_opaque_ts__WEBPACK_IMPORTED_MODULE_0__.RegistrationResponse.deserialize(this.cfg, Array.from(serverResponseBytes))\n\n        const rec = await this.client.registerFinish(deserRes, this.serverIdentity, clientIdentity)\n\n        const { record, _ } = rec\n        return record.serialize()\n    }\n\n    async loginInit(password) {\n        const ke1 = await this.client.authInit(password)\n\n        return ke1.serialize()\n    }\n\n    async loginFinish(serverResponseBytes) {\n        const credentialResponse =\n            this.client.deserializeCredentialResponse(serverResponseBytes);\n\n        const result = await this.client.loginFinish(this.state, credentialResponse);\n\n        return {\n            sessionKey: result.sessionKey,\n            exportKey: result.exportKey,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://frontend/./src/opaque.js?\n}");

/***/ },

/***/ "./src/utils.js"
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64ToBytes: () => (/* binding */ base64ToBytes),\n/* harmony export */   uint8ArrayToBase64: () => (/* binding */ uint8ArrayToBase64)\n/* harmony export */ });\nfunction base64ToBytes(base64) {\n    const binary = atob(base64)\n    const bytes = new Uint8Array(binary.length)\n\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i)\n    }\n\n    return bytes\n}\n\nfunction uint8ArrayToBase64(bytes) {\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n}\n\n//# sourceURL=webpack://frontend/./src/utils.js?\n}");

/***/ }

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Check if module exists (development only)
/******/ 		if (__webpack_modules__[moduleId] === undefined) {
/******/ 			var e = new Error("Cannot find module '" + moduleId + "'");
/******/ 			e.code = 'MODULE_NOT_FOUND';
/******/ 			throw e;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/login.js");
/******/ 	
/******/ })()
;